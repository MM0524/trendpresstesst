<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TrendPress | Prioritized Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Thêm DOMPurify cho bảo mật XSS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='50' fill='%23A100FF'/></svg>">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        :root {
            --bg-color: #0F1021; --surface-color: #191a2e; --primary-color: #A100FF;
            --primary-light: #b540ff; --text-color: #e3e8f0; --text-muted-color: #8a8da0;
            --border-color: #2d2e49; --header-height: 65px;
            --success-color: #4CAF50; /* Màu xanh lá cho thành công */
            --danger-color: #f44336;   /* Màu đỏ cho lỗi/nguy hiểm */
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        body { font-family: 'Inter', sans-serif; background-color: var(--bg-color); color: var(--text-color); line-height: 1.6; overflow-x: hidden; }
        .loader-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: var(--bg-color); display: flex; justify-content: center; align-items: center; z-index: 9999; transition: opacity 0.5s ease, visibility 0.5s ease; }
        .loader-overlay.loader-hidden { opacity: 0; visibility: hidden; }
        @keyframes pulse { 0% { top: 36px; left: 36px; width: 0; height: 0; opacity: 1; } 100% { top: 0px; left: 0px; width: 72px; height: 72px; opacity: 0; } }
        .loader-pulse { display: inline-block; position: relative; width: 80px; height: 80px; }
        .loader-pulse div { position: absolute; border: 4px solid var(--primary-light); opacity: 1; border-radius: 50%; animation: pulse 1.2s cubic-bezier(0, 0.2, 0.8, 1) infinite; }
        .loader-pulse div:nth-child(2) { animation-delay: -0.6s; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes slideInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .header { display: flex; justify-content: space-between; align-items: center; padding: 0 2rem; background-color: var(--bg-color); border-bottom: 1px solid var(--border-color); position: sticky; top: 0; z-index: 1000; height: var(--header-height); animation: fadeIn 0.5s ease-out; }
        .logo { font-size: 1.8rem; font-weight: 700; cursor: pointer; }
        .logo-trend { color: var(--primary-light); }
        .nav-links { display: flex; gap: 1.5rem; list-style: none; }
        .nav-links a { color: var(--text-muted-color); text-decoration: none; font-weight: 500; transition: color 0.3s ease; padding-bottom: 4px; border-bottom: 2px solid transparent; }
        .nav-links a:hover { color: var(--primary-color); }
        .nav-links a.active-link { color: var(--text-color); border-bottom-color: var(--primary-color); }
        .nav-actions { position: relative; display: flex; align-items: center; gap: 0.75rem; }
        .hamburger-menu { display: none; }
        .btn { padding: 0.6rem 1.2rem; border: 1px solid transparent; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.3s ease; }
        .btn:active { transform: scale(0.97); }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover { background-color: var(--primary-light); }
        .btn-secondary { background: var(--surface-color); color: var(--text-muted-color); border: 1px solid var(--border-color); }
        .btn-outline { background: transparent; color: var(--primary-light); border: 1px solid var(--primary-light); font-size: 0.8rem; padding: 0.3rem 0.8rem; }
        .btn-outline:hover { background: var(--primary-light); color: white; }
        .analyze-trend-btn { margin-right: 0.5rem; }
        .main-container { display: grid; grid-template-columns: 320px 1fr; gap: 2rem; padding: 2rem; width: 100%; max-width: 1400px; margin: auto; animation: slideInUp 0.6s ease-out; }
        .for-u-container { display: grid; grid-template-columns: 1fr 350px; gap: 2rem; padding: 2rem; width: 100%; max-width: 1400px; margin: auto; animation: slideInUp 0.6s ease-out; }
        .trending-board-container { padding: 2rem; width: 100%; max-width: 1400px; margin: auto; animation: slideInUp 0.6s ease-out; }
        .demo-banner { grid-column: 1 / -1; background-color: var(--surface-color); border: 1px solid var(--border-color); padding: 1rem; border-radius: 8px; margin-bottom: 1rem; }
        .trending-container, .for-u-content, .leaderboard-panel, #search-filter-panel { background-color: var(--surface-color); padding: 1.5rem; border-radius: 12px; border: 1px solid var(--border-color); }
        .trending-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; flex-wrap: wrap; gap: 1rem; }
        .trending-title-group { display: flex; align-items: center; gap: 0.75rem; font-size: 1.5rem; font-weight: 600; }
        .filter-buttons { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 0.75rem; /* Tăng khoảng cách giữa các nút */
            margin-bottom: 2rem; 
        }
        .filter-btn { 
            /* CẬP NHẬT: Phong cách mặc định */
            background-color: var(--surface-color); /* Nền tối hơn, phù hợp với theme */
            border: 1px solid var(--border-color); /* Viền tinh tế */
            color: var(--text-color); /* Chữ màu sáng */
            padding: 0.6rem 1.2rem; /* Tăng padding */
            border-radius: 8px; /* Bo tròn góc hơn */
            cursor: pointer; 
            font-weight: 500; /* Làm mỏng chữ hơn một chút */
            transition: all 0.2s ease; /* Transition mượt mà hơn */
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* Thêm shadow nhẹ */
        }
        .filter-btn:hover { 
            /* CẬP NHẬT: Hiệu ứng hover */
            background-color: var(--border-color); /* Nền hơi sáng lên một chút khi hover */
            border-color: var(--primary-light); /* Viền màu primary-light */
            color: var(--primary-light); /* Chữ màu primary-light */
            transform: translateY(-2px); /* Nâng nhẹ nút lên */
            box-shadow: 0 4px 10px rgba(0,0,0,0.2); /* Shadow rõ hơn */
        }
        .filter-btn.active { 
            /* Giữ nguyên, vì nó đã trông đẹp rồi */
            background-color: var(--primary-color); 
            color: white; 
            border-color: var(--primary-color); 
            box-shadow: 0 4px 10px rgba(161,0,255,0.3); /* Shadow đặc biệt cho active */
        }
        .trend-card { background-color: var(--bg-color); padding: 1.5rem; border: 1px solid var(--border-color); border-radius: 10px; margin-bottom: 1rem; transition: transform 0.3s ease, box-shadow 0.3s ease; animation: slideInUp 0.5s ease-out forwards; opacity: 0; }
        .trend-card.animated { opacity: 1; } /* Class for animating cards */
        .trend-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(0,0,0,0.2); }
        /* NEW: Added flex for header */
        .trend-card-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 1rem; }
        .trend-title { flex-grow: 1; font-size: 1.25rem; font-weight: 600; cursor: pointer; transition: color 0.3s; margin-bottom: 0.5rem; }
        .trend-title:hover { color: var(--primary-light); }
        .trend-description { margin-bottom: 1rem; color: var(--text-muted-color); }
        /* NEW: Styles for trend metadata */
        .trend-meta { font-size: 0.85rem; color: var(--text-muted-color); text-align: right; }
        .trend-meta-submitter { font-weight: 500; }
        .trend-meta-date { display: block; font-size: 0.75rem; }

        .loading-spinner { width: 20px; height: 20px; border: 2px solid rgba(161, 0, 255, 0.1); border-top: 2px solid var(--primary-color); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .ai-status-indicator { position: fixed; top: 80px; right: 20px; background: var(--surface-color); border: 1px solid var(--border-color); border-radius: 8px; padding: 0.5rem 1rem; font-size: 0.8rem; z-index: 1001; }
        .ai-status-indicator.online { border-color: var(--success-color); color: var(--success-color); }
        .ai-status-indicator.offline { border-color: var(--danger-color); color: var(--danger-color); }
        .trend-footer { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem; }
        .trend-tags { display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; }
        .tag { 
            padding: 0.25rem 0.75rem; 
            border-radius: 999px; 
            font-size: 0.8rem; 
            font-weight: 500; 
            transition: all 0.2s ease; /* Thêm transition */
        }
        .tag.category { background-color: var(--primary-color); color: white; }
        .tag.hashtag { 
            background-color: var(--surface-color); 
            border: 1px solid var(--border-color); 
            color: var(--text-muted-color); 
            cursor: pointer; 
        }
        .tag.hashtag:hover { /* Hiệu ứng hover cho hashtag */
            background-color: var(--border-color);
            border-color: var(--primary-light);
            color: var(--primary-light);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .trend-actions { display: flex; align-items: center; gap: 1rem; }
        .btn-follow { background-color: var(--surface-color); border: 1px solid var(--border-color); color: var(--text-muted-color); }
        .btn-follow.followed { background-color: var(--primary-color); color: white; }

        /* NEW: Style for the new Summary button - CẬP NHẬT để giống .btn-outline */
        .btn-predict { 
            background: transparent;
            color: var(--primary-light);
            border: 1px solid var(--primary-light);
            padding: 0.3rem 0.8rem;
            border-radius: 8px;
            cursor: pointer; 
            font-weight: 600;
            transition: all 0.3s ease;
            font-size: 0.8rem;
        }
        .btn-predict:hover {
            background: var(--primary-light); 
            color: white; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }

        #trends-footer { text-align: center; margin-top: 1.5rem; }
        .leaderboard-panel h3 { font-size: 1.5rem; font-weight: 600; margin-bottom: 1.5rem; }
        .leaderboard-widget { margin-bottom: 2rem; }
        .leaderboard-widget h4 { color: var(--primary-light); margin-bottom: 1rem; font-size: 1rem; font-weight: 600; }
        .leaderboard-widget ul { list-style: none; padding: 0; display: flex; flex-direction: column; gap: 0.5rem; }
        .leaderboard-widget li { background-color: var(--bg-color); padding: 0.75rem 1rem; border-radius: 6px; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; transition: background-color 0.2s ease; cursor: pointer; }
        .leaderboard-widget li:hover { background-color: var(--border-color); }

        /* NEW: Hover effects for the Trending Board lists */
        .tb-leaderboard-list li {
            transition: all 0.2s ease-in-out; /* Làm mượt hiệu ứng chuyển đổi */
            cursor: pointer; /* Đảm bảo con trỏ chuột thay đổi để báo hiệu có thể click */
        }

        .tb-leaderboard-list li:hover {
            background-color: var(--border-color); /* Thay đổi màu nền khi hover */
            transform: translateY(-2px); /* Nâng nhẹ mục lên trên */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Thêm bóng đổ nhẹ */
        }

        .view-source-btn, .btn-follow { display: inline-flex; } /* ALWAYS SHOW if logged in and is work */
        /* Removed the specific body.work-account-view rule as it's implied now */
        .dropdown { display: none; position: absolute; top: 110%; right: 0; background-color: var(--surface-color); border: 1px solid var(--border-color); border-radius: 8px; min-width: 250px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); z-index: 10; }
        .dropdown.show { display: block; }
        .dropdown-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem 1rem; color: var(--text-color); text-decoration: none; cursor: pointer; }
        .dropdown-item:hover { background-color: var(--border-color); }
        #search-filter-panel h3 { font-size: 1.5rem; font-weight: 600; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 0.75rem; }
        #search-input { width: 100%; background-color: var(--bg-color); border: 1px solid var(--border-color); color: var(--text-color); padding: 0.75rem; border-radius: 8px; font-size: 1rem; margin-bottom: 1.5rem; }
        #hashtag-filter { margin-top: 1rem; }
        #hashtag-filter h4 { color: var(--text-muted-color); font-size: 0.9rem; margin-bottom: 1rem; }
        #hashtag-list { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        .hashtag-btn { 
            background-color: var(--bg-color); 
            border: 1px solid var(--border-color); 
            color: var(--text-muted-color); 
            padding: 0.25rem 0.75rem; 
            border-radius: 20px; 
            cursor: pointer; 
            transition: all 0.2s ease; 
        }
        .hashtag-btn:hover { /* Hiệu ứng hover cho hashtag buttons trong filter */
            border-color: var(--primary-light); 
            color: var(--primary-light); 
            background-color: var(--surface-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .hashtag-btn.active { 
            border-color: var(--primary-color); 
            color: var(--primary-light); 
            background-color: var(--surface-color);
        }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(15, 16, 33, 0.85); backdrop-filter: blur(5px); z-index: 2000; display: flex; justify-content: center; align-items: center; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal-overlay.show { opacity: 1; visibility: visible; }
        .modal-content { background-color: var(--surface-color); padding: 2rem; border-radius: 12px; width: 90%; max-width: 500px; text-align: center; position: relative; border: 1px solid var(--border-color); transform: scale(0.95) translateY(10px); transition: transform 0.3s ease, opacity 0.3s ease; opacity: 0; }
        .modal-overlay.show .modal-content { transform: scale(1) translateY(0); opacity: 1; }
        .modal-close { position: absolute; top: 1rem; right: 1rem; background: none; border: none; color: var(--text-muted-color); font-size: 1.5rem; cursor: pointer; }
        .modal-title { font-size: 1.5rem; margin-bottom: 1rem; }
        .modal-body { margin-bottom: 1.5rem; color: var(--text-muted-color); }
        /* NEW: Style for error messages */
        .modal-body.error-message { color: var(--danger-color); }

        #login-choice-modal .modal-content { max-width: 420px; }
        #login-choice-modal .modal-title { color: var(--primary-light); font-size: 1.75rem; margin-bottom: 0.5rem; }
        #login-choice-modal .modal-body { margin-bottom: 2rem; font-size: 0.9rem; }
        /* Cập nhật các nút đăng nhập để chỉ có SVG và span trống */
        #login-choice-modal .btn-social { background-color: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.75rem; padding: 1rem; text-align: center; font-size: 0.95rem; font-weight: 500; position: relative; }
        #login-choice-modal .btn-social:hover { border-color: var(--primary-color); background-color: #21233a; }
        #login-choice-modal .btn-social svg { position: absolute; left: 1.5rem; stroke: var(--text-muted-color); width: 20px; height: 20px; }
        .preferences-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; text-align: left; margin-bottom: 1.5rem; }
        #ai-insight-modal .modal-content {
            max-width: 650px; /* Tăng chiều rộng để dễ đọc hơn */
            width: 90%;
            text-align: left;
            padding: 0; /* Xóa padding cũ để tạo layout header/body/footer */
            background-color: var(--bg-color); /* Nền tối hơn modal thường */
            border: 1px solid var(--border-color);
        }

        #ai-insight-modal .modal-header {
            padding: 1.5rem 2rem;
            border-bottom: 1px solid var(--border-color);
        }

        #ai-insight-modal .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 0;
            color: var(--text-color);
        }

        #ai-insight-modal .modal-body { 
            max-height: 65vh; 
            overflow-y: auto;
            padding: 2rem; 
            line-height: 1.7;
            color: var(--text-muted-color);
        }
        
        /* Custom Scrollbar cho Modal Body */
        #ai-insight-modal .modal-body::-webkit-scrollbar {
            width: 8px;
        }
        #ai-insight-modal .modal-body::-webkit-scrollbar-track {
            background: var(--bg-color);
        }
        #ai-insight-modal .modal-body::-webkit-scrollbar-thumb {
            background-color: var(--border-color);
            border-radius: 10px;
            border: 2px solid var(--bg-color);
        }
        #ai-insight-modal .modal-body::-webkit-scrollbar-thumb:hover {
            background-color: var(--primary-color);
        }

        /* Style cho từng phần phân tích của AI */
        .ai-section {
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-left: 3px solid var(--primary-color); /* Thêm một dải màu nhấn */
            border-radius: 8px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .ai-section:last-child {
            margin-bottom: 0;
        }

        .ai-section h4 { 
            color: var(--primary-light); 
            margin-top: 0;
            margin-bottom: 1rem;
            font-size: 1.2rem;
            font-weight: 600;
            border-bottom: none; /* Bỏ gạch chân cũ */
            padding-bottom: 0;
        }

        .ai-section p {
            margin-bottom: 1rem;
            color: var(--text-muted-color);
        }
        .ai-section p:last-child {
            margin-bottom: 0;
        }

        .ai-section ul {
            list-style-type: none; /* Bỏ dấu chấm đầu dòng mặc định */
            padding-left: 0;
            margin-bottom: 1rem;
        }

        .ai-section li {
            margin-bottom: 0.75rem;
            padding-left: 1.5rem;
            position: relative;
        }

        /* Tạo dấu check hoặc mũi tên tùy chỉnh cho list item */
        .ai-section li::before {
            content: '✓'; /* Hoặc '→' */
            color: var(--primary-color);
            font-weight: bold;
            position: absolute;
            left: 0;
            top: 1px;
        }

        .ai-section strong {
            color: var(--text-color); /* Làm chữ đậm nổi bật hơn */
            font-weight: 600;
        }
        /* End NEW AI Deep Dive styles */


        .tb-header { border-bottom: 1px solid var(--border-color); padding-bottom: 1rem; margin-bottom: 1.5rem; }
        .tb-search-container { display: flex; gap: 1rem; margin-bottom: 1rem; }
        .tb-search-box { flex: 1; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 8px; padding: 0.75rem 1rem; display: flex; align-items: center; }
        .tb-search-box.compare { background-color: var(--surface-color); }
        .tb-search-box input { background: transparent; border: none; color: var(--text-color); font-size: 1rem; width: 100%; outline: none; }
        .tb-search-box.compare input::placeholder { color: var(--text-muted-color); }
        .tb-search-chips { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem; } /* Added flex-wrap */
        .tb-search-chip { background-color: var(--bg-color); border: 1px solid var(--primary-color); color: var(--primary-light); padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.9rem; display: flex; align-items: center; gap: 0.25rem; }
        .tb-search-chip-remove { background: none; border: none; color: var(--text-muted-color); cursor: pointer; font-size: 1rem; margin-left: 0.5rem; }
        .tb-search-chip-remove:hover { color: var(--primary-light); }

        /* Cập nhật các bộ lọc để có giao diện gọn gàng hơn */
        .tb-filters { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); 
            gap: 1rem; 
            margin-bottom: 1rem; 
        }

        /* Đảm bảo các select boxes vẫn trông đẹp */
        .tb-filter-select, #tb-status-select, #tb-custom-timeframe-select, #main-region-filter, #main-timeframe-filter, #main-source-filter {
            background-color: var(--bg-color); 
            border: 1px solid var(--border-color); 
            color: var(--text-color); 
            padding: 0.5rem 1rem; 
            border-radius: 8px; 
            font-size: 0.9rem;
            appearance: none; 
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23e3e8f0" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/></svg>'); 
            background-repeat: no-repeat;
            background-position-x: 95%;
            background-position-y: center;
            cursor: pointer;
        }

        /* NEW: Styles for main view additional filters */
        #main-view-additional-filters {
            margin-top: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem; /* Giảm khoảng cách giữa các bộ lọc */
        }
        #main-view-additional-filters h4 {
            margin-bottom: 0.25rem; /* Giảm khoảng cách với select bên dưới */
        }


        @media (max-width: 768px) {
            .tb-filters {
                grid-template-columns: 1fr; 
            }
        }


        .tb-leaderboards-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 1.5rem; }
        .tb-leaderboard { background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; }
        .tb-leaderboard-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; color: var(--text-muted-color); font-size: 0.9rem; }
        .tb-leaderboard-list ol { list-style: none; padding: 0; }
        .tb-leaderboard-list li { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 0; border-bottom: 1px solid var(--border-color); font-weight: 500; }
        .tb-leaderboard-list li:last-child { border-bottom: none; }
        .tb-leaderboard-list .rank { color: var(--text-muted-color); margin-right: 1rem; }
        .tb-leaderboard-list .term { flex-grow: 1; }
        .tb-leaderboard-list .growth { color: var(--success-color); }
        #tb-chart-container { margin-top: 2rem; background-color: var(--bg-color); border: 1px solid var(--border-color); border-radius: 8px; padding: 1.5rem; }
        /* CẬP NHẬT: Giới hạn chiều cao biểu đồ */
        #tb-chart-container canvas { width: 100%; max-height: 350px; }
        /* NEW CHART CONTAINER STYLE */
        #user-trends-chart-container {
            margin-top: 2rem;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
        }
        #user-trends-chart-container canvas {
            width: 100%;
            max-height: 350px;
        }

        /* NEW: Style for the Trend Overview Modal */
        #trend-overview-modal .modal-content {
            max-width: 600px; /* Adjust max width as needed */
            width: 90%;
            text-align: left;
            padding: 1.5rem; /* Match trend-card padding */
        }

        /* Make sure inner elements match trend-card styles */
        #trend-overview-modal #trend-overview-body .trend-card-header {
            margin-bottom: 0.5rem; /* Adjust if needed */
        }
        #trend-overview-modal #trend-overview-body .trend-description {
            margin-bottom: 1rem;
        }
        #trend-overview-modal #trend-overview-body .trend-tags {
            margin-bottom: 1rem;
        }
        #trend-overview-modal #trend-overview-body .trend-footer {
            border-top: 1px solid var(--border-color); /* Add a separator if desired */
            padding-top: 1rem;
            margin-top: 1rem;
        }

        #tb-chart-title, #user-trends-chart-title {
            color: var(--text-color);
            margin-bottom: 1.5rem;
            font-size: 1.25rem;
            font-weight: 600;
            cursor: pointer; /* Giữ lại con trỏ để báo hiệu có thể click */
            display: inline-block; /* Để không chiếm toàn bộ chiều rộng */
            transition: color 0.2s ease;
        }
        
        #tb-chart-title:hover, #user-trends-chart-title:hover {
            color: var(--primary-light);
        }
        
        /* NEW: Styles for Search Result Details */
       #tb-search-details-wrapper {
            display: grid;
            /* 
              Tự động tạo các cột. Mỗi cột sẽ cố gắng rộng bằng 1 phần (1fr),
              nhưng sẽ không nhỏ hơn 400px. Khi không đủ không gian, nó sẽ tự xuống dòng.
            */
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            margin-top: 2rem;
        }

        .tb-search-details-container {
             display: flex;
             flex-direction: column;
             gap: 2rem;
        }

        .tb-details-panel {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            /* Đảm bảo các panel có chiều cao tối thiểu ngay cả khi trống */
            min-height: 200px; 
        }

        .tb-details-panel h4 {
            color: var(--primary-light);
            margin-bottom: 1.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            word-break: break-all; /* Ngăn tiêu đề dài làm vỡ layout */
        }
        
        .tb-article-list, .tb-related-list {
            list-style: none;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .tb-article-item, .tb-related-item {
            padding: 1rem;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .tb-article-item:hover, .tb-related-item:hover {
            border-color: var(--primary-light);
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.25);
        }

        .tb-article-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: var(--text-color);
        }

        .tb-article-source {
            font-size: 0.8rem;
            color: var(--text-muted-color);
        }

        .tb-related-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .tb-related-query {
            font-weight: 500;
            color: var(--text-color);
        }
        
        .tb-related-value {
            font-size: 0.9rem;
            color: var(--success-color);
            font-weight: 600;
            background-color: rgba(76, 175, 80, 0.1);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }

        /* Responsive: Chuyển về 1 cột trên màn hình nhỏ */
        @media (max-width: 900px) {
            #tb-search-details-wrapper {
                grid-template-columns: 1fr;
            }
        }

        #tb-comparison-table-container {
            margin-top: 2rem;
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            color: var(--text-color);
        }

        #tb-comparison-table-container h4 {
            color: var(--primary-light);
            margin-bottom: 1.5rem;
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .comparison-table th, .comparison-table td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .comparison-table th {
            color: var(--text-muted-color);
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
        }

        .comparison-table tbody tr:hover {
            background-color: var(--bg-color);
        }

        .comparison-term-cell {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 600;
        }

        .term-color-swatch {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .comparison-value {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .comparison-source {
            font-size: 0.8rem;
            color: var(--text-muted-color);
            background-color: var(--bg-color);
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
        }
        
        .footer { background-color: var(--surface-color); border-top: 1px solid var(--border-color); padding: 3rem 0 1rem 0; }
        .footer-content { max-width: 1200px; margin: 0 auto; padding: 0 2rem; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 2rem; }
        .footer-title { color: var(--primary-light); font-size: 1.1rem; font-weight: 600; margin-bottom: 1rem; }
        .footer-links { list-style: none; padding: 0; }
        .footer-links a { color: var(--text-muted-color); text-decoration: none; }
        .footer-links a:hover { color: var(--primary-light); }
        .footer-bottom { border-top: 1px solid var(--border-color); margin-top: 2rem; padding-top: 1.5rem; text-align: center; color: var(--text-muted-color); font-size: 0.9rem; }
        @media (max-width: 1024px) { .main-container, .for-u-container { grid-template-columns: 1fr; } #search-filter-panel, .leaderboard-panel { grid-row: 1; }
            /* NEW: Adjust dropdown position for smaller screens */
            .nav-actions .dropdown { right: 1rem; left: auto; }
        }
        @media (max-width: 768px) {
            .header { padding: 0 1rem; }
            .nav-links { position: fixed; top: var(--header-height); left: 0; width: 100%; height: calc(100vh - var(--header-height)); background-color: var(--bg-color); flex-direction: column; align-items: center; padding-top: 2rem; transform: translateX(-100%); transition: transform 0.3s ease-in-out; }
            nav.nav-active .nav-links { transform: translateX(0); }
            .hamburger-menu { display: flex; flex-direction: column; justify-content: space-around; width: 2rem; height: 2rem; background: transparent; border: none; cursor: pointer; z-index: 10; }
            .hamburger-menu.active span:nth-child(1) { transform: translateY(0.875rem) rotate(45deg); } /* Adjusted transform origin */
            .hamburger-menu.active span:nth-child(2) { opacity: 0; }
            .hamburger-menu.active span:nth-child(3) { transform: translateY(-0.875rem) rotate(-45deg); } /* Adjusted transform origin */
            .main-container, .for-u-container, .trending-board-container { padding: 1rem; }
            .trending-title-group { font-size: 1.25rem; }
            .trend-card { padding: 1rem; }
            .trend-title { font-size: 1.1rem; }
            .tb-leaderboards-grid { grid-template-columns: 1fr; }
            .footer-content { grid-template-columns: 1fr; text-align: center; }
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="loader-overlay" id="loader"><div class="loader-pulse"><div></div><div></div></div></div>
    <header class="header">
        <div class="logo" id="logo"><span class="logo-trend">Trend</span>Press</div>
        <div class="ai-status-indicator" id="ai-status-indicator"><span id="ai-status-text"></span></div>
        <nav id="main-nav">
            <ul class="nav-links">
                <li><a href="#" id="nav-top-trends"></a></li>
                <li><a href="#" id="nav-trending-board"></a></li>
                <li id="nav-for-u" class="hidden"><a href="#"></a></li>
                <li><a href="#" id="nav-about"></a></li>
            </ul>
        </nav>
        <div style="display: flex; align-items: center; gap: 1rem;">
             <div class="nav-actions">
                <div class="language-switcher"><button class="btn btn-outline" id="language-toggle">VN</button></div>
                <!-- REMOVED: Sign In button -->
                <div id="user-menu"> <!-- Changed to always visible -->
                    <button class="btn btn-secondary" id="user-email-btn"></button>
                    <div class="dropdown" id="user-dropdown">
                        <div class="dropdown-header" id="dropdown-user-email"></div>
                        <!-- REMOVED/HIDDEN: Work/School option as accountType is always 'work' -->
                        <a href="#" class="dropdown-item hidden" id="dropdown-work-school"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path></svg><span></span></a>
                        <a href="#" class="dropdown-item" id="dropdown-sign-out"><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg><span></span></a>
                    </div>
                </div>
            </div>
            <button class="hamburger-menu" id="hamburger-menu"><span></span><span></span><span></span></button>
        </div>
    </header>
    
    <main class="main-container" id="main-view-container">
        <aside id="search-filter-panel">
            <h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg><span id="search-filter-title"></span></h3>
            <input type="text" id="search-input" placeholder="">
            <div id="hashtag-filter">
                <h4></h4>
                <div id="hashtag-list"></div>
            </div>
            <!-- NEW: Filters for main view (Region, Timeframe, Source) -->
            <div id="main-view-additional-filters" style="margin-top: 1.5rem; display: flex; flex-direction: column; gap: 0.75rem;">
                <h4 style="color: var(--text-muted-color); font-size: 0.9rem; margin-bottom: 0.25rem;" id="main-filter-title-region"></h4>
                <select id="main-region-filter" class="tb-filter-select">
                    <!-- Populated by JS -->
                </select>

                <h4 style="color: var(--text-muted-color); font-size: 0.9rem; margin-bottom: 0.25rem;" id="main-filter-title-timeframe"></h4>
                <select id="main-timeframe-filter" class="tb-filter-select">
                    <!-- Populated by JS -->
                </select>

                <h4 style="color: var(--text-muted-color); font-size: 0.9rem; margin-bottom: 0.25rem;" id="main-filter-title-source"></h4>
                <select id="main-source-filter" class="tb-filter-select">
                    <!-- Populated by JS -->
                </select>
            </div>
        </aside>
        <section class="trending-container">
            <div class="demo-banner"><h2></h2><p></p></div>
            <div class="trending-header">
                <div class="trending-title-group"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg><span id="trending-header-text"></span></div>
                 <button class="btn btn-secondary hidden" id="clear-filter-btn"></button>
            </div>
            <div class="filter-buttons" id="filter-buttons"></div>
            <div id="trends-list"></div>
            <div id="trends-footer"><button class="btn btn-primary" id="load-more-btn"></button></div>
        </section>
    </main>

    <section class="for-u-container hidden" id="for-u-view-container">
        <div class="for-u-content">
            <div class="trending-header">
                <div class="trending-title-group"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path></svg><span></span></div>
            </div>
            <div id="for-u-trends-list"></div>
            <div id="for-u-trends-footer"><button class="btn btn-primary" id="for-u-load-more-btn"></button></div>
        </div>
        <aside class="leaderboard-panel" id="for-u-leaderboard-panel">
             <h3></h3><div id="for-u-leaderboards"></div>
        </aside>
    </section>

    <section class="trending-board-container hidden" id="trending-board-view-container">
        <h2 id="tb-main-title" style="font-size: 2rem; margin-bottom: 1.5rem;"></h2>
        <div class="tb-header">
            <div class="tb-search-container" id="tb-search-container">
                <div class="tb-search-box">
                    <input type="text" id="tb-search-input" placeholder="">
                </div>
                <div class="tb-search-box compare">
                    <input type="text" id="tb-compare-input" placeholder="">
                </div>
            </div>
            <div class="tb-search-chips hidden" id="tb-search-chips-container"></div>
            <div class="tb-filters" style="grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));"> <!-- Adjusted grid columns -->
                <select id="tb-region-filter" class="tb-filter-select">
                    <!-- Options will be populated by JS -->
                </select>
                <select id="tb-category-filter" class="tb-filter-select">
                    <!-- Options will be populated by JS -->
                </select>
                <!-- Cập nhật: Kết hợp tb-timeframe-filter và tb-status-filter-container -->
                <select id="tb-status-select" class="tb-filter-select">
                    <option value="hottest"></option>
                    <option value="latest"></option>
                    <option value="outdated"></option>
                    <option value="predictive"></option>
                </select>
                <select id="tb-custom-timeframe-select" class="tb-filter-select">
                    <!-- Options populated by JS based on status -->
                </select>
            </div>
        </div>
        <div id="tb-default-view">
            <div class="tb-leaderboards-grid">
                <div class="tb-leaderboard">
                    <div class="tb-leaderboard-header" id="tb-topic-list-header"><span></span> <span></span></div>
                    <div class="tb-leaderboard-list" id="tb-topic-list"></div>
                </div>
                <div class="tb-leaderboard">
                    <div class="tb-leaderboard-header" id="tb-query-list-header"><span></span> <span></span></div>
                    <div class="tb-leaderboard-list" id="tb-query-list"></div>
                </div>
            </div>
        </div>
        <div id="tb-chart-container">
            <h4 id="tb-chart-title"></h4>
            <canvas id="hot-trends-chart"></canvas>
        </div>
        <div id="user-trends-chart-container" class="hidden">
            <h4 id="user-trends-chart-title"></h4>
            <canvas id="user-trends-chart"></canvas>
        </div>
        <!-- Container for User's Favorite Categories Chart -->
        <div id="user-trends-chart-container" class="hidden">
            <h4 id="user-trends-chart-title"></h4>
            <canvas id="user-trends-chart"></canvas>
        </div>
         <div id="tb-search-details-wrapper" class="hidden">
            <!-- JavaScript sẽ tự động chèn nội dung chi tiết vào đây -->
        </div>
        <div id="tb-search-details-container" class="hidden">
            <div class="tb-details-panel" id="tb-top-articles-panel">
                <h4 id="tb-top-articles-title"></h4>
                <ul class="tb-article-list" id="tb-top-articles-list"></ul>
            </div>
            <div class="tb-details-panel" id="tb-related-queries-panel">
                <h4 id="tb-related-queries-title"></h4>
                <ul class="tb-related-list" id="tb-related-queries-list"></ul>
            </div>
        </div>
        <div id="tb-comparison-table-container" class="hidden">
            <h4 id="tb-comparison-title"></h4>
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th id="th-term"></th>
                        <th id="th-total-engagement"></th>
                        <th id="th-peak-engagement"></th>
                        <th id="th-source"></th>
                    </tr>
                </thead>
                <tbody id="tb-comparison-body">
                    <!-- JavaScript sẽ tự động chèn các hàng vào đây -->
                </tbody>
            </table>
        </div>
    </section>

    <div class="modal-overlay" id="preferences-modal"><div class="modal-content"><button class="modal-close" data-close="preferences-modal">&times;</button><h3 class="modal-title"></h3><p class="modal-body"></p><div class="preferences-grid" id="preferences-grid"></div><div class="modal-actions"><button class="btn btn-primary" id="save-preferences-btn"></button></div></div></div>
    <div class="modal-overlay" id="premium-modal"><div class="modal-content"><button class="modal-close" data-close="premium-modal">&times;</button><h3 class="modal-title"></h3><p class="modal-body"></p><div class="modal-actions"><button class="btn btn-primary" id="premium-login-btn"></button></div></div></div>
    <div class="modal-overlay" id="ai-insight-modal">
        <div class="modal-content">
            <button class="modal-close" data-close="ai-insight-modal">&times;</button>
            <div class="modal-header">
                <h3 class="modal-title" id="ai-insight-title"></h3>
            </div>
            <div class="modal-body" id="ai-insight-body">
                <!-- Nội dung AI sẽ được chèn vào đây -->
            </div>
        </div>
    </div>
    
    <!-- NEW: Trend Overview Modal -->
    <div class="modal-overlay" id="trend-overview-modal">
        <div class="modal-content" id="trend-overview-content">
            <button class="modal-close" data-close="trend-overview-modal">&times;</button>
            <div id="trend-overview-body">
                <!-- Trend Card content will be inserted here by JavaScript -->
            </div>
        </div>
    </div>
    <!-- End NEW Trend Overview Modal -->

    <div class="modal-overlay" id="about-modal"><div class="modal-content"><button class="modal-close" data-close="about-modal">&times;</button><h3 class="modal-title"></h3><p class="modal-body"></p></div></div>

    <div class="modal-overlay" id="explanation-modal">
        <div class="modal-content" style="max-width: 450px;">
            <button class="modal-close" data-close="explanation-modal">&times;</button>
            <h3 class="modal-title" id="explanation-title"></h3>
            <p class="modal-body" id="explanation-body" style="text-align: left;"></p>
        </div>
    </div>
    
    <footer class="footer">
        <div class="footer-content">
            <div class="footer-section"><h4 class="footer-title">TrendPress</h4><p class="footer-description"></p></div>
            <div class="footer-section"><h4 class="footer-title"></h4><ul class="footer-links"><li><a href="#" id="footer-top-trends"></a></li><li><a href="#" id="footer-trending-board"></a></li><li><a href="#" id="footer-about"></a></a></li></ul></div>
            <div class="footer-section"><h4 class="footer-title"></h4><ul class="footer-links"><li><span id="feat-ai-analysis"></span></li><li><span id="feat-trend-prediction"></span></li><li><span id="feat-leaderboards"></span></li><li><span id="feat-personal-recommendations"></span></li></ul></div>
            <div class="footer-section"><h4 class="footer-title"></h4><div class="footer-contact"><p id="contact-email"></p><p id="contact-support"></p></div></div>
        </div>
        <div class="footer-bottom"><p></p></div>
    </footer>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // CẬP NHẬT: user object sẽ luôn ở trạng thái đã đăng nhập và là tài khoản "work"
        let user = { 
            isLoggedIn: true, 
            email: 'guest@trendpulse.com', // Email mặc định hoặc có thể để null
            accountType: 'work', // Thiết lập là 'work' để truy cập các tính năng trước đây là premium
            preferences: [], 
            hasSetPreferences: false, // Để hiển thị preferences modal lần đầu
            followedTrends: [], 
            tbSearchTerms: [] 
        };
        const TRENDS_PER_PAGE = 5;
        let displayedTrends = { main: 0, forU: 0 };
        let currentFilter = { 
            type: 'category', 
            value: 'All', 
            searchTerm: '', 
            hashtag: '',
            region: 'global', // Default region filter for main view
            timeframe: '12m', // Default timeframe filter for main view
            source: 'All'    // Default source filter for main view
        };
        let currentView = localStorage.getItem('currentView') || 'main';
        let hotTrendsChart = null;
        let analysisChart = null;
        let userTrendsChart = null;
        let allTrends = []; 
        let masterTrendsList = [];
        let currentSearchResults = [];
        let lastRenderedSearchTerms = [];
        let categories = []; 
        let regions = [];
        let sources = [];
        let currentLanguage = localStorage.getItem('lang') || 'vi';

        let currentTrendStatus = {
            status: 'hottest', 
            customTimeframe: '7d' 
        };

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        const translations = {
            vi: {
                'Top Trends': 'Top News',
                'Trending Now': 'Tin Tức Nóng',
                'Find & Filter Trends': 'Tìm & Lọc Tin Tức',
                'Welcome to TrendPulse': 'Chào mừng đến với TrendPress',
                'About TrendPulse': 'Giới thiệu TrendPress',
                'No trends found.': 'Không tìm thấy tin tức nào.',
                'Your Followed Trends': 'Tin Tức Bạn Theo Dõi',
                'Your Favorite Trends - Interest Over Time': 'Tin Tức Yêu Thích - Mức Độ Quan Tâm',
                'Trends for': 'Tin tức cho',
                'Trend Prediction': 'Dự Đoán Tin Tức',
                'Show All Trends': 'Hiển thị tất cả tin tức',
                'Choose an account to continue to TrendPulse.': 'Chọn tài khoản để tiếp tục với TrendPress.',
                'Top 5 Hot Trends': 'Top 5 Tin Tức Nóng Nhất',
                'Footer Description': 'Nền tảng phân tích và dự đoán tin tức hàng đầu, giúp bạn nắm bắt những thay đổi mới nhất trong thế giới số.',
                'Find Trends': 'Tìm & Lọc Tin Tức',
                'Comparison Details': 'So sánh Chi tiết',
                'Search Term': 'Từ khóa',
                'Total Engagement': 'Tổng Tương tác',
                'Peak Engagement': 'Tương tác Đỉnh điểm',
                'Data Source': 'Nguồn Dữ liệu',
                // --- Các key còn lại ---
                'Trending Board': 'Trending Board', 'For U': 'Dành cho bạn', 'For You': 'Dành cho bạn', 'About': 'Giới thiệu', 'Sign Out': 'Đăng xuất',
                'Discover what’s next. Act before the rest.': 'Khám phá tương lai. Hành động trước đối thủ.',
                'Load More': 'Tải thêm', 'View Source': 'Xem nguồn', 'Following': 'Đang theo dõi', '❤️ Follow': '❤️ Theo dõi', '🔍 Analyze': 'Phân tích', 'Summary': '🔮 Dự đoán', 
                'AI Analysis Summary for': 'Dự đoán AI cho',
                'Welcome! Set Your Preferences': 'Chào mừng! Thiết lập sở thích của bạn', "Select the categories you're interested in in for a personalized experience.": 'Chọn các danh mục bạn quan tâm để có trải nghiệm cá nhân hóa.', 'Save Preferences': 'Lưu sở thích',
                'Trending Board Dashboard': 'Bảng điều khiển Trending Board', 'Category Leaderboards': 'Bảng xếp hạng danh mục',
                "A crowdsourced platform to predict, visualize, and analyze emerging trends. Click a trend's title to get AI-powered insights.": "Nền tảng cộng đồng để dự đoán, trực quan hóa và phân tích xu hướng mới nổi. Nhấp vào tiêu đề tin tức để có thông tin chi tiết từ AI.",
                'Quick Links': 'Liên kết nhanh', 'Features': 'Tính năng', 'AI Analysis': 'Phân tích AI', 'Leaderboards': 'Bảng xếp hạng', 'Personal Recommendations': 'Gợi ý cá nhân', 'Contact': 'Liên hệ', 'Email: info@trendpulse.com': 'Email: info@trendpress.com', 'Support: support@trendpulse.com': 'Hỗ trợ: support@trendpress.com', 'All rights reserved.': 'Tất cả quyền được bảo lưu.',
                'AI: Checking...': 'AI: Đang kiểm tra...', 'AI: Ready': 'AI: Sẵn sàng', 'AI: Unavailable': 'AI: Không khả dụng', 'AI: Connection error': 'AI: Lỗi kết nối', 'AI Insight for': 'AI Insight cho', 'AI Analysis Summary for': 'Tóm tắt Phân tích AI cho',
                'Analyzing trend...': 'Đang phân tích tin tức...', 'Unable to analyze trend.': 'Không thể phân tích tin tức.',
                'Interest Over Time': 'Mức Độ Quan Tâm', 'Engagement': 'Tương tác', 'Popular Tags': 'Thẻ Phổ Biến', 'Trending Topics': 'Chủ đề tìm kiếm', 'Trending Queries': 'Cụm từ tìm kiếm', 'Growth': 'Gia tăng', 'All Categories': 'Tất cả danh mục',
                'Search by keyword...': 'Tìm kiếm theo từ khóa...', 'Add search term': 'Thêm cụm từ tìm kiếm', '+ Compare': '+ So sánh',
                'Hottest News': 'Tin tức Nóng nhất', 'Latest News': 'Tin tức Mới nhất', 'Outdated News': 'Tin tức Cũ', 'Predictive News': 'Tin tức Dự đoán',
                'Rising': 'Đột phá', 'No Title Available': 'Không có tiêu đề', 'No Description Available': 'Không có mô tả',
                'Related Queries': 'Cụm từ tìm kiếm liên quan', 'No related queries.': 'Không có cụm từ liên quan.',
                'What is Engagement Score?': 'Điểm Tương tác là gì?', 'Engagement Score': 'Điểm Tương tác', 'Engagement Score Explanation': 'Đây là một chỉ số tổng hợp dựa trên lượt xem, lượt tìm kiếm và các tương tác khác để đo lường mức độ phổ biến của một xu hướng.',
                'Hottest': 'Hot nhất', 'Latest': 'Mới nhất', 'Outdated': 'Lỗi thời', 'Predictive': 'Dự đoán',
                'Last 1 hour': '1 giờ qua', 'Last 6 hours': '6 giờ qua', 'Last 24 hours': '24 giờ qua', 'Last 3 days': '3 ngày qua', 'Last 7 days': '7 ngày qua', 'Last 30 days': '30 ngày qua', 'Last 90 days': '90 ngày qua', 'Last 1 year': '1 năm qua',
                'Next 3 days': '3 ngày tới', 'Next 5 days': '5 ngày tới', 'Next 7 days': '7 ngày tới',
                'Region': 'Khu vực', 'Timeframe': 'Khung thời gian', 'Source': 'Nguồn', 'All Sources': 'Tất cả nguồn',
                'Germany': 'Đức', 'France': 'Pháp', 'Europe': 'Châu Âu', 'China': 'Trung Quốc', 'South Korea': 'Hàn Quốc', 'India': 'Ấn Độ', 'Australia': 'Úc', 'Japan': 'Nhật Bản'
            },
            en: {
                'Top Trends': 'Top News',
                'Trending Now': 'Hot News',
                'Find & Filter Trends': 'Find & Filter News',
                'Welcome to TrendPulse': 'Welcome to TrendPress',
                'About TrendPulse': 'About TrendPress',
                'No trends found.': 'No news found.',
                'Your Followed Trends': 'Your Followed News',
                'Your Favorite Trends - Interest Over Time': 'Your Favorite News - Interest Over Time',
                'Trends for': 'News for',
                'Trend Prediction': 'News Prediction',
                'Show All Trends': 'Show All News',
                'Choose an account to continue to TrendPulse.': 'Choose an account to continue to TrendPress.',
                'Top 5 Hot Trends': 'Top 5 Hot News',
                'Footer Description': 'A leading platform for news analysis and prediction, helping you stay ahead of the curve in the digital world.',
                'Find Trends': 'Find & Filter News',
                'Comparison Details': 'Comparison Details',
                'Search Term': 'Search Term',
                'Total Engagement': 'Total Engagement',
                'Peak Engagement': 'Peak Engagement',
                'Data Source': 'Data Source',
                // --- Các key còn lại ---
                'Trending Board': 'Trending Board', 'For U': 'For U', 'About': 'About', 'Sign Out': 'Sign Out',
                'Discover what’s next. Act before the rest.': 'Discover what’s next. Act before the rest.',
                'Load More': 'Load More', 'View Source': 'View Source', 'Following': 'Following', '❤️ Follow': '❤️ Follow', '🔍 Analyze': 'Analyze', 'Summary': '🔮 Predict',
                'AI Analysis Summary for': 'AI Prediction for',
                'Welcome! Set Your Preferences': 'Welcome! Set Your Preferences', "Select the categories you're interested in in for a personalized experience.": "Select the categories you're interested in for a personalized experience.", 'Save Preferences': 'Save Preferences',
                'Trending Board Dashboard': 'Trending Board Dashboard', 'Category Leaderboards': 'Category Leaderboards',
                "A crowdsourced platform to predict, visualize, and analyze emerging trends. Click a trend's title to get AI-powered insights.": "A crowdsourced platform to predict, visualize, and analyze emerging news. Click a news title to get AI-powered insights.",
                'Quick Links': 'Quick Links', 'Features': 'Features', 'AI Analysis': 'AI Analysis', 'Leaderboards': 'Leaderboards', 'Personal Recommendations': 'Personal Recommendations', 'Contact': 'Contact', 'Email: info@trendpulse.com': 'Email: info@trendpress.com', 'Support: support@trendpulse.com': 'Support: support@trendpress.com', 'All rights reserved.': 'All rights reserved.',
                'AI: Checking...': 'AI: Checking...', 'AI: Ready': 'AI: Ready', 'AI: Unavailable': 'AI: Unavailable', 'AI: Connection error': 'AI: Connection error', 'AI Insight for': 'AI Insight for', 'AI Analysis Summary for': 'AI Analysis Summary for',
                'Analyzing trend...': 'Analyzing news...', 'Unable to analyze trend.': 'Unable to analyze news.',
                'Interest Over Time': 'Interest Over Time', 'Engagement': 'Engagement', 'Popular Tags': 'Popular Tags', 'Trending Topics': 'Trending Topics', 'Trending Queries': 'Trending Queries', 'Growth': 'Growth', 'All Categories': 'All Categories',
                'Search by keyword...': 'Search by keyword...', 'Add search term': 'Add search term', '+ Compare': '+ Compare',
                'Hottest News': 'Hottest News', 'Latest News': 'Latest News', 'Outdated News': 'Outdated News', 'Predictive News': 'Predictive News',
                'Rising': 'Rising', 'No Title Available': 'No Title Available', 'No Description Available': 'No Description Available',
                'Related Queries': 'Related Queries', 'No related queries.': 'No related queries found.',
                'What is Engagement Score?': 'What is Engagement Score?', 'Engagement Score': 'Engagement Score', 'Engagement Score Explanation': 'This is a composite metric based on views, searches, and other interactions to measure a trend\'s popularity.',
                'Hottest': 'Hottest', 'Latest': 'Latest', 'Outdated': 'Outdated', 'Predictive': 'Predictive',
                'Last 1 hour': 'Last 1 hour', 'Last 6 hours': 'Last 6 hours', 'Last 24 hours': 'Last 24 hours', 'Last 3 days': 'Last 3 days', 'Last 7 days': 'Last 7 days', 'Last 30 days': 'Last 30 days', 'Last 90 days': 'Last 90 days', 'Last 1 year': 'Last 1 year',
                'Next 3 days': 'Next 3 days', 'Next 5 days': 'Next 5 days', 'Next 7 days': 'Next 7 days',
                'Region': 'Region', 'Timeframe': 'Timeframe', 'Source': 'Source', 'All Sources': 'All Sources',
                'de': 'Germany', 'fr': 'France', 'eu': 'Europe', 'cn': 'China', 'kr': 'South Korea', 'in': 'India', 'au': 'Australia', 'jp': 'Japan'
            }
        };

        const i18nBindings = [
            { selector: '#nav-top-trends', key: 'Top Trends' }, 
            { selector: '#trending-header-text', key: 'Trending Now' },
            { selector: '#search-filter-title', key: 'Find Trends' }, // Đổi sang key ngắn gọn và nhất quán hơn
            { selector: '.demo-banner h2', key: 'Welcome to TrendPulse' },
            { selector: '#about-modal .modal-title', key: 'About TrendPulse' },
            { selector: '#footer-top-trends', key: 'Top Trends' },
            { selector: '#user-trends-chart-title', key: 'Your Favorite Trends - Interest Over Time' },
            { selector: '#clear-filter-btn', key: 'Show All Trends' },
            { selector: '#for-u-leaderboard-panel h3', key: 'Category Leaderboards' },
            { selector: '#feat-trend-prediction', key: 'Trend Prediction' },
            { selector: '#tb-comparison-title', key: 'Comparison Details' },
            { selector: '#th-term', key: 'Search Term' },
            { selector: '#th-total-engagement', key: 'Total Engagement' },
            { selector: '#th-peak-engagement', key: 'Peak Engagement' },
            { selector: '#th-source', key: 'Data Source' },
            
            // Các binding không thay đổi
            { selector: '#nav-trending-board', key: 'Trending Board' },
            { selector: '#nav-for-u a', key: 'For U' }, 
            { selector: '#nav-about', key: 'About' },
            { selector: '#dropdown-sign-out span:last-child', key: 'Sign Out' },
            { selector: '.demo-banner p', key: 'Discover what’s next. Act before the rest.' },
            { selector: '#load-more-btn', key: 'Load More' }, 
            { selector: '#for-u-load-more-btn', key: 'Load More' },
            { selector: '.for-u-container .trending-title-group span', key: 'For You' },
            { selector: '#preferences-modal .modal-title', key: 'Welcome! Set Your Preferences' }, 
            { selector: '#preferences-modal .modal-body', key: "Select the categories you're interested in in for a personalized experience." },
            { selector: '#save-preferences-btn', key: 'Save Preferences' },
            { selector: '#tb-main-title', key: 'Trending Board Dashboard' },
            { selector: '#about-modal .modal-body', key: "A crowdsourced platform to predict, visualize, and analyze emerging trends. Click a trend's title to get AI-powered insights." },
            { selector: '.footer-section:nth-child(1) .footer-description', key: 'Footer Description' }, 
            { selector: '.footer-section:nth-child(2) .footer-title', key: 'Quick Links' },
            { selector: '#footer-trending-board', key: 'Trending Board' },
            { selector: '#footer-about', key: 'About' }, 
            { selector: '.footer-section:nth-child(3) .footer-title', key: 'Features' },
            { selector: '#feat-ai-analysis', key: 'AI Analysis' },
            { selector: '#feat-leaderboards', key: 'Leaderboards' }, 
            { selector: '#feat-personal-recommendations', key: 'Personal Recommendations' },
            { selector: '.footer-section:nth-child(4) .footer-title', key: 'Contact' }, 
            { selector: '#contact-email', key: 'Email: info@trendpulse.com' },
            { selector: '#contact-support', key: 'Support: support@trendpulse.com' }, 
            { selector: '#ai-insight-title', key: 'AI Insight for' },
            { selector: '#hashtag-filter h4', key: 'Popular Tags' },
            { selector: '#tb-search-input', attr: 'placeholder', key: 'Add search term' },
            { selector: '#tb-compare-input', attr: 'placeholder', key: '+ Compare' },
            { selector: '#search-input', attr: 'placeholder', key: 'Search by keyword...' },
            { selector: '#tb-status-select option[value="hottest"]', key: 'Hottest' },
            { selector: '#tb-status-select option[value="latest"]', key: 'Latest' },
            { selector: '#tb-status-select option[value="outdated"]', key: 'Outdated' },
            { selector: '#tb-status-select option[value="predictive"]', key: 'Predictive' },
            { selector: '#main-filter-title-region', key: 'Region' },
            { selector: '#main-filter-title-timeframe', key: 'Timeframe' },
            { selector: '#main-filter-title-source', key: 'Source' },
            { selector: '#main-source-filter option[value="All"]', key: 'All Sources' },
            { selector: '#main-timeframe-filter option[value="1h"]', key: 'Last 1 hour' },
            { selector: '#main-timeframe-filter option[value="6h"]', key: 'Last 6 hours' },
            { selector: '#main-timeframe-filter option[value="24h"]', key: 'Last 24 hours' },
            { selector: '#main-timeframe-filter option[value="3d"]', key: 'Last 3 days' },
            { selector: '#main-timeframe-filter option[value="7d"]', key: 'Last 7 days' },
            { selector: '#main-timeframe-filter option[value="1m"]', key: 'Last 30 days' },
            { selector: '#main-timeframe-filter option[value="3m"]', key: 'Last 90 days' },
            { selector: '#main-timeframe-filter option[value="12m"]', key: 'Last 1 year' }
        ];

        const DOM = {
            body: document.body, mainNav: document.getElementById('main-nav'), hamburgerMenu: document.getElementById('hamburger-menu'),
            logo: document.getElementById('logo'), 
            // REMOVED: signInBtn: document.getElementById('sign-in-btn'), // THIS LINE IS REMOVED
            userMenu: document.getElementById('user-menu'),
            userEmailBtn: document.getElementById('user-email-btn'), dropdownHeader: document.getElementById('dropdown-user-email'), userDropdown: document.getElementById('user-dropdown'),
            dropdownSignOut: document.getElementById('dropdown-sign-out'), dropdownWorkSchool: document.getElementById('dropdown-work-school'),
            navTopTrends: document.getElementById('nav-top-trends'), navTrendingBoard: document.getElementById('nav-trending-board'),
            navForU: document.getElementById('nav-for-u'), navAbout: document.getElementById('nav-about'),
            modalCloses: document.querySelectorAll('.modal-close'), mainViewContainer: document.getElementById('main-view-container'),
            forUViewContainer: document.getElementById('for-u-view-container'), trendingBoardContainer: document.getElementById('trending-board-view-container'),
            trendsList: document.getElementById('trends-list'), forUTrendsList: document.getElementById('for-u-trends-list'),
            loadMoreBtn: document.getElementById('load-more-btn'), forULoadMoreBtn: document.getElementById('for-u-load-more-btn'),
            filterButtonsContainer: document.getElementById('filter-buttons'), clearFilterBtn: document.getElementById('clear-filter-btn'),
            preferencesGrid: document.getElementById('preferences-grid'), savePreferencesBtn: document.getElementById('save-preferences-btn'),
            searchInput: document.getElementById('search-input'), hashtagList: document.getElementById('hashtag-list'),
            tbSearchInput: document.getElementById('tb-search-input'), tbCompareInput: document.getElementById('tb-compare-input'),
            tbCategoryFilter: document.getElementById('tb-category-filter'), 
            tbRegionFilter: document.getElementById('tb-region-filter'),
            tbSearchChipsContainer: document.getElementById('tb-search-chips-container'),
            tbDefaultView: document.getElementById('tb-default-view'),
            tbTopicListHeader: document.getElementById('tb-topic-list-header'),
            tbQueryListHeader: document.getElementById('tb-query-list-header'),
            tbChartTitle: document.getElementById('tb-chart-title'),
            userTrendsChartContainer: document.getElementById('user-trends-chart-container'),
            userTrendsChartTitle: document.getElementById('user-trends-chart-title'),
            tbStatusSelect: document.getElementById('tb-status-select'),
            tbCustomTimeframeSelect: document.getElementById('tb-custom-timeframe-select'),
            mainRegionFilter: document.getElementById('main-region-filter'),
            mainTimeframeFilter: document.getElementById('main-timeframe-filter'),
            mainSourceFilter: document.getElementById('main-source-filter'),

            // NEW: Trend Overview Modal elements
            trendOverviewModal: document.getElementById('trend-overview-modal'),
            trendOverviewBody: document.getElementById('trend-overview-body'),
        };

        function t(key) { return (translations[currentLanguage] && translations[currentLanguage][key]) || key; }

        function openModal(modalId) { document.getElementById(modalId).classList.add('show'); }
        function closeModal(modalId) { document.getElementById(modalId).classList.remove('show'); }

        async function fetchLiveTrends() {
            const url = `/.netlify/builders/trends-builder`;
            console.log("Fetching MASTER list of trends from:", url);
            
            try {
                const res = await fetch(url);
                if (!res.ok) {
                    const errorText = await res.text();
                    throw new Error(`HTTP error! Status: ${res.status} - ${errorText}`);
                }
                const data = await res.json();
                if (!data.success) {
                    throw new Error(data.message || "Failed to fetch trends from builder.");
                }
                
                const fetchedTrends = Array.isArray(data.trends) ? data.trends : [];
                masterTrendsList = fetchedTrends;
                applyTrendOrdering();
                
                return fetchedTrends;
            } catch (e) {
                console.warn('Failed to fetch master list of trends:', e.message);
                if (DOM.trendsList) {
                    DOM.trendsList.innerHTML = `<p class="modal-body error-message" style="text-align: center;">Could not load trends. Please try again later.</p>`;
                }
                return [];
            }
        }

        async function analyzeTrendSecurely(trend, analysisType) {
            try {
                const response = await fetch('/.netlify/functions/analyze-trend', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ trend, analysisType, language: currentLanguage }) });
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Server function error: ${response.status} ${errorText}`);
                }
                const result = await response.json();
                if (!result.success) throw new Error(result.message || 'Analysis failed on the server');

                if (analysisType === 'summary') {
                    // CẬP NHẬT: result.data bây giờ là một JSON object { successScore: X, summary: "<html>" }
                    return result.data; 
                }
                // Dành cho 'detailed', result.data là Markdown string
                const cleanHtml = DOMPurify.sanitize(result.data, { USE_PROFILES: { html: true } });
                const formatDetailedInsight = (markdownText) => markdownText
                    .replace(/### (.*?)\n/g, '<h4>$1</h4>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/^\* (.*$)/gm, '<li>$1</li>')
                    .replace(/<\/li>\n/g, '</li>')
                    .replace(/(\r\n|\n|\r)/gm, '<br>')
                    .replace(/<br><br><li>/g, '<ul><li>')
                    .replace(/<\/li><br><h4>/g, '</li></ul><h4>')
                    .concat('</ul>');

                return formatDetailedInsight(cleanHtml);

            } catch (error) { console.error("Secure analysis request failed:", error); throw error; }
        }

        function preprocessTrends(trends) {
            if (!trends || trends.length === 0) return [];
            
            const maxValues = {
                views: Math.max(1, ...trends.map(trendItem => trendItem.views || 0)),
                interactions: Math.max(1, ...trends.map(trendItem => trendItem.interactions || 0)),
                searches: Math.max(1, ...trends.map(trendItem => trendItem.searches || 0)),
                votes: Math.max(1, ...trends.map(trendItem => trendItem.votes || 0)),
            };
            
            trends.forEach((trendItem, i) => {
                
                trendItem.hotnessScore = calculateHotnessScore(trendItem, maxValues);
                // Ensure type is present (backend might not always send it)
                trendItem.type = trendItem.type || (i % 3 === 0 ? 'topic' : 'query');
            });
            return trends;
        }

        function calculateHotnessScore(trend, maxValues) {
            const weights = { views: 0.2, interactions: 0.4, searches: 0.3, votes: 0.1 };
            const normViews = (trend.views / maxValues.views) || 0;
            const normInteractions = (trend.interactions / maxValues.interactions) || 0;
            const normSearches = (trend.searches / maxValues.searches) || 0;
            const normVotes = (trend.votes / maxValues.votes) || 0;
            return (normViews * weights.views) + (normInteractions * weights.interactions) + (normSearches * weights.searches) + (normVotes * weights.votes);
        }

        function applyTranslations() {
            i18nBindings.forEach(b => {
                const el = document.querySelector(b.selector);
                if (el) {
                    if (b.attr) {
                        el.setAttribute(b.attr, t(b.key));
                    } else {
                        el.textContent = t(b.key);
                    }
                }
            });
            document.querySelector('.footer-bottom p').textContent = `© 2024 TrendPulse. ${t('All rights reserved.')}`;
            document.getElementById('ai-status-text').textContent = t('AI: Checking...');
            if (DOM.tbTopicListHeader && DOM.tbTopicListHeader.children[0]) DOM.tbTopicListHeader.children[0].textContent = t('Trending Topics');
            if (DOM.tbQueryListHeader && DOM.tbQueryListHeader.children[0]) DOM.tbQueryListHeader.children[0].textContent = t('Trending Queries');

            populateRegionsFilter(DOM.mainRegionFilter);
            populateRegionsFilter(DOM.tbRegionFilter); 

            populateMainTimeframeFilter(); // Populate main-timeframe-filter
            populateSourceFilter(); // Populate main-source-filter

            const currentStatus = DOM.tbStatusSelect ? DOM.tbStatusSelect.value : 'hottest';
            if (DOM.tbStatusSelect) {
                DOM.tbStatusSelect.innerHTML = `
                    <option value="hottest">${t('Hottest')}</option>
                    <option value="latest">${t('Latest')}</option>
                    <option value="outdated">${t('Outdated')}</option>
                    <option value="predictive">${t('Predictive')}</option>
                `;
                DOM.tbStatusSelect.value = currentStatus;
            }
            populateCustomTimeframeOptions(currentTrendStatus.status);

            populateCategoryFilters(); // For both main and TB category filters
        }

        function updateLanguageToggleUI() {
            document.getElementById('language-toggle').textContent = currentLanguage === 'vi' ? 'VN' : 'EN';
        }

        // NEW: Function to generate the inner HTML of a trend card
        function createTrendCardContent(trend) {
            if (!trend || (!trend.title_en && !trend.title_vi)) { 
                console.error("Invalid trend data for card content: Missing title", trend); 
                return ''; 
            }
            const { title: localizedTitle, description: localizedDesc } = getLocalizedTrendText(trend);
            const isFollowed = user.followedTrends.includes(trend.id);

            // Using DOMPurify directly for any user-generated content for extra safety
            const cleanTitle = DOMPurify.sanitize(localizedTitle, { USE_PROFILES: { html: true } });
            const cleanDescription = DOMPurify.sanitize(localizedDesc, { USE_PROFILES: { html: true } });

            return `
                <div class="trend-card-header">
                    <h3 class="trend-title" data-trend-id="${trend.id}">${cleanTitle}</h3>
                    <div class="trend-meta">
                        <span class="trend-meta-submitter">by ${DOMPurify.sanitize(trend.submitter || 'Anon')}</span>
                        <span class="trend-meta-date">on ${new Date(trend.date).toLocaleDateString(currentLanguage)}</span>
                    </div>
                </div>
                <p class="trend-description">${cleanDescription}</p>
                <div class="trend-footer">
                    <div class="trend-tags">
                        <span class="tag category">${t(trend.category)}</span>
                        ${(trend.tags || []).map(tag => `<span class="tag hashtag" data-tag="${DOMPurify.sanitize(tag)}">#${DOMPurify.sanitize(tag)}</span>`).join('')}
                    </div>
                    <div class="trend-actions">
                        <a href="${DOMPurify.sanitize(trend.source || '#')}" target="_blank" rel="noopener noreferrer" class="btn btn-outline view-source-btn">${t('View Source')}</a>
                        
                        <!-- **** NÚT SUMMARY ĐÃ ĐƯỢC THAY THẾ BẰNG NÚT PREDICT **** -->
                        <button class="btn btn-outline btn-predict" data-trend-id="${trend.id}" data-analysis-type="prediction">${t('Summary')}</button>
                        
                        <button class="btn btn-outline analyze-trend-btn" data-trend-id="${trend.id}" data-analysis-type="detailed">${t('🔍 Analyze')}</button>
                        <button class="btn btn-follow ${isFollowed ? 'followed' : ''}" data-trend-id="${trend.id}">${isFollowed ? t('Following') : t('❤️ Follow')}</button>
                    </div>
                </div>`;
        }
        // MODIFY: Update createTrendCard to use createTrendCardContent
        function createTrendCard(trend, delay = 0) {
            const trendCard = document.createElement('div');
            trendCard.className = 'trend-card';
            trendCard.dataset.trendId = trend.id;
            trendCard.innerHTML = createTrendCardContent(trend);
            
            setTimeout(() => trendCard.classList.add('animated'), delay);
            return trendCard;
        }

        function getVisibleTrends() {
            let sourceList = [...masterTrendsList];

            // Apply main view filters
            if (currentFilter.type === 'category' && currentFilter.value !== 'All') {
                sourceList = sourceList.filter(trendItem => trendItem && trendItem.category === currentFilter.value);
            }
            if (currentFilter.hashtag) {
                sourceList = sourceList.filter(trendItem => trendItem && (trendItem.tags || []).includes(currentFilter.hashtag));
            }
            if (currentFilter.searchTerm) {
                const term = currentFilter.searchTerm.toLowerCase();
                sourceList = sourceList.filter(trendItem => trendItem && (
                    (trendItem.title_vi && trendItem.title_vi.toLowerCase().includes(term)) ||
                    (trendItem.description_vi && trendItem.description_vi.toLowerCase().includes(term)) ||
                    (trendItem.title_en && trendItem.title_en.toLowerCase().includes(term)) ||
                    (trendItem.description_en && trendItem.description_en.toLowerCase().includes(term))
                ));
            }
            if (currentFilter.region && currentFilter.region !== 'global') {
                sourceList = sourceList.filter(trend => trend.region === currentFilter.region);
            }
            if (currentFilter.timeframe && currentFilter.timeframe !== 'all') { // Use currentFilter.timeframe
                sourceList = sourceList.filter(trend => isTrendRelevantForTimeframe(trend, currentFilter.timeframe));
            }
            if (currentFilter.source && currentFilter.source !== 'All') {
                sourceList = sourceList.filter(trend => trend.submitter === currentFilter.source);
            }

            // For 'forU' view, apply user-specific filters on top of already filtered sourceList
            if (currentView === 'forU') {
                // Since accountType is always 'work', this check simplifies
                const preferenceTrends = sourceList.filter(trendItem => trendItem && user.preferences.includes(trendItem.category));
                const followedTrendsData = sourceList.filter(trendItem => trendItem && user.followedTrends.includes(trendItem.id));
                const combined = [...followedTrendsData, ...preferenceTrends];
                const uniqueTrendIds = new Set(combined.map(trendItem => trendItem.id));
                return Array.from(uniqueTrendIds)
                    .map(id => sourceList.find(trendItem => trendItem.id === id))
                    .filter(Boolean)
                    .sort((a,b) => b.hotnessScore - a.hotnessScore);
            }
            
            return sourceList.filter(Boolean);
        }

        function displayTrends() {
            if (currentView === 'trendingBoard') return;

            const listElement = currentView === 'main' ? DOM.trendsList : DOM.forUTrendsList;
            const footerButton = currentView === 'main' ? DOM.loadMoreBtn : DOM.forULoadMoreBtn;
            
            allTrends = getVisibleTrends();
            
            if (!listElement) {
                console.error("Trends list element not found for current view:", currentView);
                return;
            }

            listElement.innerHTML = '';
            let trendsRendered = 0;
            const numToDisplay = Math.min(displayedTrends[currentView] || TRENDS_PER_PAGE, allTrends.length);

            if (numToDisplay === 0 && allTrends.length === 0) {
                 listElement.innerHTML = `<p class="modal-body" style="text-align: center;">${t('No trends found.')}</p>`;
            }

            for (let i = 0; i < numToDisplay; i++) {
                listElement.appendChild(createTrendCard(allTrends[i], i * 50));
                trendsRendered++;
            }

            displayedTrends[currentView] = trendsRendered;

            if (footerButton) {
                footerButton.classList.toggle('hidden', displayedTrends[currentView] >= allTrends.length);
            }

            if (currentView === 'forU') {
                generateCategoryLeaderboards('for-u-leaderboards', user.preferences.length > 0 ? user.preferences : categories.slice(0, 3));
            }
            updateClearFilterButtonVisibility();
        }

        function updateClearFilterButtonVisibility() {
            const hasActiveFilter = (currentFilter.value !== 'All' || currentFilter.searchTerm !== '' || currentFilter.hashtag !== '' || 
                                     currentFilter.region !== 'global' || currentFilter.timeframe !== '12m' || currentFilter.source !== 'All');
            if (DOM.clearFilterBtn) {
                DOM.clearFilterBtn.classList.toggle('hidden', !hasActiveFilter);
            }
        }

        async function clearMainViewFilters() {
            currentFilter = { type: 'category', value: 'All', searchTerm: '', hashtag: '', region: 'global', timeframe: '12m', source: 'All' };
            if (DOM.searchInput) DOM.searchInput.value = '';
            if (DOM.hashtagList) DOM.hashtagList.querySelectorAll('.hashtag-btn').forEach(btn => btn.classList.remove('active'));
            
            updateUIForFilter();
        }

        function loadMoreTrends() {
            displayedTrends[currentView] += TRENDS_PER_PAGE;
            displayTrends();
        }

        async function switchView(view) {
            currentView = view;
            localStorage.setItem('currentView', view);
            displayedTrends.main = 0;
            displayedTrends.forU = 0;

            [DOM.mainViewContainer, DOM.forUViewContainer, DOM.trendingBoardContainer].forEach(container => {
                if (container) container.classList.add('hidden');
            });

            if (view === 'main') {
                if (DOM.mainViewContainer) DOM.mainViewContainer.classList.remove('hidden');
            } else if (view === 'forU') {
                // No longer need login check here, as user is always 'work'
                if (DOM.forUViewContainer) DOM.forUViewContainer.classList.remove('hidden');
            } else if (view === 'trendingBoard') {
                // No longer need login check here, as user is always 'work'
                if (DOM.trendingBoardContainer) DOM.trendingBoardContainer.classList.remove('hidden');
                
                if (DOM.tbCategoryFilter) DOM.tbCategoryFilter.value = 'All';
                if (DOM.tbRegionFilter) DOM.tbRegionFilter.value = 'global';
                user.tbSearchTerms = [];
                if (DOM.tbSearchInput) DOM.tbSearchInput.value = '';
                if (DOM.tbCompareInput) DOM.tbCompareInput.value = '';
                
                if(DOM.tbStatusSelect) DOM.tbStatusSelect.value = 'hottest';
                currentTrendStatus.status = 'hottest';
                currentTrendStatus.customTimeframe = '7d';
                populateCustomTimeframeOptions(currentTrendStatus.status); // Update options for hottest

                await createHotTrendsChart(); // This will fetch filtered data and update allTrends
            }

            if (view !== 'trendingBoard') {
                displayTrends();
            }
            
            updateActiveNav(view);
            if (DOM.hamburgerMenu && DOM.mainNav.classList.contains('nav-active')) {
                DOM.hamburgerMenu.click();
            }
        }

        function updateAuthUI() {
            if (DOM.body) DOM.body.className = '';
            // Since user is always logged in, simplify this part
            if (user.isLoggedIn) {
                if (DOM.body) DOM.body.classList.add('logged-in');
                // DOM.signInBtn is removed from HTML and DOM object, no longer referenced
                if (DOM.userMenu) DOM.userMenu.classList.remove('hidden'); // Always show user menu
                if (DOM.userEmailBtn) DOM.userEmailBtn.textContent = user.email;
                if (DOM.dropdownHeader) DOM.dropdownHeader.textContent = user.email;
                if (DOM.navForU) DOM.navForU.classList.remove('hidden'); // 'For U' is always available
                DOM.dropdownWorkSchool.classList.add('hidden'); // Ensure hidden
                if (DOM.body) DOM.body.classList.add('work-account-view'); // Always apply work-account-view for full features
            }
            // else block is no longer relevant as isLoggedIn is always true
            displayTrends();
        }
        
        function populateRegionsFilter(selectElement) {
            if (!selectElement) return;

            const dynamicRegions = [...new Set(masterTrendsList.map(trendItem => trendItem.region))].filter(Boolean).sort();
            
            let optionsHtml = `<option value="global">${t('Global')}</option>`;
            
            const regionsToAdd = ['vn', 'us', 'uk', 'in', 'jp', 'de', 'fr', 'ca', 'au', 'eu', 'cn', 'kr']; // CẬP NHẬT: Thêm các mã vùng mới
            regionsToAdd.forEach(regionCode => {
                if (dynamicRegions.includes(regionCode)) {
                    optionsHtml += `<option value="${regionCode}">${t(regionCode.toUpperCase()) || regionCode}</option>`;
                }
            });

            const currentSelection = selectElement.value;
            selectElement.innerHTML = optionsHtml;
            selectElement.value = Array.from(selectElement.options).some(opt => opt.value === currentSelection) ? currentSelection : 'global';
        }

        function populateMainTimeframeFilter() {
            if (!DOM.mainTimeframeFilter) return;
            const currentMainTimeframe = DOM.mainTimeframeFilter.value;
            DOM.mainTimeframeFilter.innerHTML = `
                <option value="1h">${t('Last 1 hour')}</option>
                <option value="6h">${t('Last 6 hours')}</option>
                <option value="24h">${t('Last 24 hours')}</option>
                <option value="3d">${t('Last 3 days')}</option>
                <option value="7d">${t('Last 7 days')}</option>
                <option value="1m">${t('Last 30 days')}</option>
                <option value="3m">${t('Last 90 days')}</option>
                <option value="12m">${t('Last 1 year')}</option>
            `;
            DOM.mainTimeframeFilter.value = currentMainTimeframe;
            if (!DOM.mainTimeframeFilter.value) DOM.mainTimeframeFilter.value = '12m'; // Default
            currentFilter.timeframe = DOM.mainTimeframeFilter.value; // Sync with currentFilter
        }

        function populateSourceFilter() {
            if (!DOM.mainSourceFilter) return;
            const uniqueSources = [...new Set(masterTrendsList.map(trendItem => trendItem.submitter))].filter(Boolean).sort();
            const currentSource = DOM.mainSourceFilter.value;

            let optionsHtml = `<option value="All">${t('All Sources') || 'All Sources'}</option>`;
            uniqueSources.forEach(sourceName => {
                optionsHtml += `<option value="${sourceName}">${sourceName}</option>`;
            });
            DOM.mainSourceFilter.innerHTML = optionsHtml;
            DOM.mainSourceFilter.value = Array.from(DOM.mainSourceFilter.options).some(opt => opt.value === currentSource) ? currentSource : 'All';
            currentFilter.source = DOM.mainSourceFilter.value; // Sync with currentFilter
        }

        function populateCategoryFilters() {
            categories = [...new Set(masterTrendsList.map(trendItem => trendItem.category))].sort();
            const allOptionText = t('All Categories');
            if (DOM.filterButtonsContainer) {
                DOM.filterButtonsContainer.innerHTML = [`<button class="filter-btn ${currentFilter.value === 'All' ? 'active' : ''}" data-filter="All">${allOptionText}</button>`, ...categories.map(category => `<button class="filter-btn ${category === currentFilter.value ? 'active' : ''}" data-filter="${category}">${t(category)}</button>`)].join('');
            }

            if (DOM.tbCategoryFilter) {
                const currentCategory = DOM.tbCategoryFilter.value;
                DOM.tbCategoryFilter.innerHTML = `<option value="All">${allOptionText}</option>`;
                categories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat;
                    option.textContent = t(cat);
                    DOM.tbCategoryFilter.appendChild(option);
                });
                DOM.tbCategoryFilter.value = currentCategory;
            }
        }

        function populatePreferenceCheckboxes() {
            if (DOM.preferencesGrid) {
                DOM.preferencesGrid.innerHTML = categories.map(category => `<div class="preference-item"><label><input type="checkbox" name="preference" value="${category}" ${user.preferences.includes(category) ? 'checked' : ''}> ${t(category)}</label></div>`).join('');
            }
        }

        function updateUIForFilter() {
            if (DOM.filterButtonsContainer) {
                DOM.filterButtonsContainer.querySelectorAll('.filter-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.filter === currentFilter.value));
            }
            if (DOM.hashtagList) {
                DOM.hashtagList.querySelectorAll('.hashtag-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.hashtag === currentFilter.hashtag));
            }
            if (DOM.searchInput) DOM.searchInput.value = currentFilter.searchTerm;

            if (DOM.mainRegionFilter) DOM.mainRegionFilter.value = currentFilter.region;
            if (DOM.mainTimeframeFilter) DOM.mainTimeframeFilter.value = currentFilter.timeframe;
            if (DOM.mainSourceFilter) DOM.mainSourceFilter.value = currentFilter.source;


            displayedTrends.main = 0;
            displayTrends();
            updateClearFilterButtonVisibility();
        }

        function populateHashtagFilters() {
            const hashtagCounts = masterTrendsList.reduce((acc, trendItem) => {
                (trendItem.tags || []).forEach(tag => { if (tag) acc[tag] = (acc[tag] || 0) + 1; });
                return acc;
            }, {});
            const popularHashtags = Object.entries(hashtagCounts).sort((a, b) => b[1] - a[1]).slice(0, 10).map(entry => entry[0]);
            if (DOM.hashtagList) {
                DOM.hashtagList.innerHTML = popularHashtags.map(tag => `<button class="hashtag-btn ${currentFilter.hashtag === tag ? 'active' : ''}" data-hashtag="${tag}">#${tag}</button>`).join('');
            }
        }

        function generateCategoryLeaderboards(containerId, categoriesToShow) {
            const container = document.getElementById(containerId);
            if (!container) return;
            container.innerHTML = '';

            if (user.isLoggedIn && user.followedTrends.length > 0) {
                const leaderboardDiv = document.createElement('div');
                leaderboardDiv.className = 'leaderboard-widget';
                const listItems = masterTrendsList.filter(trendItem => user.followedTrends.includes(trendItem.id))
                                   .map(trendItem => `<li data-trend-id="${trendItem.id}">${truncateText(getLocalizedTrendText(trendItem).title, 35)}</li>`).join('');
                leaderboardDiv.innerHTML = `<h4>${t('Your Followed Trends')}</h4><ul>${listItems}</ul>`;
                container.appendChild(leaderboardDiv);
            }

            const uniqueCategoriesToShow = Array.from(new Set(categoriesToShow)).sort();
            uniqueCategoriesToShow.forEach(category => {
                const trendsInCategory = masterTrendsList.filter(trendItem => trendItem.category === category);
                if (trendsInCategory.length === 0) return;
                const sortedTrends = [...trendsInCategory].sort((a, b) => b.hotnessScore - a.hotnessScore);
                const topTrends = sortedTrends.slice(0, 3);

                const leaderboardDiv = document.createElement('div');
                    leaderboardDiv.className = 'leaderboard-widget';
                let listItems = topTrends.map(trendItem => `<li data-trend-id="${trendItem.id}">${truncateText(getLocalizedTrendText(trendItem).title, 35)}</li>`).join('');
                leaderboardDiv.innerHTML = `<h4>${t('Top in')} ${t(category)}</h4><ul>${listItems}</ul>`;
                container.appendChild(leaderboardDiv);
            });
        }

        function renderSummaryAnalysis(analysisData) {
            const modalBody = document.getElementById('ai-insight-body');
            if (!modalBody) return;
            modalBody.classList.remove('error-message');
            // analysisData.summary đã là HTML từ backend
            modalBody.innerHTML = `
                <!-- REMOVED: Success Score from summary view -->
                <div style="margin-bottom: 1rem;"><h4>${t('Summary')}</h4>${DOMPurify.sanitize(analysisData.summary, { USE_PROFILES: { html: true } })}</div>
                <div><h4>${t('Interest Over Time')}</h4></div>`;
            renderAnalysisChart(generateChartDataFromScore(analysisData.successScore).historicalData, generateChartDataFromScore(analysisData.successScore).futureProjection);
        }

        function renderDetailedAnalysis(htmlContent) {
            const modalBody = document.getElementById('ai-insight-body');
            if (!modalBody) return;
            modalBody.classList.remove('error-message');
            modalBody.innerHTML = htmlContent;
        }

        function renderAnalysisChart(historicalData, futureProjection) {
            const canvas = document.createElement('canvas');
            const insightBody = document.getElementById('ai-insight-body');
            if (!insightBody) {
                console.error("AI Insight body not found for chart rendering.");
                return;
            }

            if (analysisChart) analysisChart.destroy();
            
            // Xóa các canvas cũ nếu có
            insightBody.querySelectorAll('canvas').forEach(c => c.remove());
            
            insightBody.appendChild(canvas);
            const labels = ['-1d', '-6h', '-3h', 'Now', '+1d', '+4d', '+7d'];
            const lastHistoricalPoint = historicalData[historicalData.length - 1];
            const projectionData = [null, null, null, lastHistoricalPoint, futureProjection[0] || null, futureProjection[1] || null, futureProjection[2] || null];
            
            analysisChart = new Chart(canvas.getContext('2d'), {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        { label: t('Historical'), data: [...historicalData, null, null, null], borderColor: '#00C8FF', tension: 0.1, pointBackgroundColor: '#00C8FF', pointBorderColor: '#fff', pointHoverRadius: 7, fill: false },
                        { label: t('Projection'), data: projectionData, borderColor: '#A100FF', borderDash: [5, 5], tension: 0.4, pointBackgroundColor: '#A100FF', pointBorderColor: '#fff', pointHoverRadius: 7, fill: false }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: true, labels: { color: '#8a8da0', usePointStyle: true, boxWidth: 8 } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${formatNumber(context.parsed.y)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { grid: { display: false }, ticks: { color: '#8a8da0' } },
                        y: { 
                            grid: { color: 'rgba(255, 255, 255, 0.1)'}, 
                            ticks: { 
                                color: '#8a8da0', 
                                callback: (v) => formatNumber(v) 
                            }, 
                            beginAtZero: true,
                            min: 0,
                            suggestedMax: Math.max(...historicalData, ...futureProjection.filter(val => val !== null)) * 1.2 || 1000,
                            // Thêm chú thích cho trục Y
                            title: {
                                display: true,
                                text: t('Interest Level'), // Dùng hàm dịch
                                color: 'var(--text-muted-color)',
                                font: {
                                    size: 12,
                                    weight: '500'
                                }
                            }
                        }
                    }
                }
            });
        }

        function getCombinedMetric(trend) { 
            return (trend.views || 0) + (trend.interactions || 0) + (trend.searches || 0); 
        }

        function getLocalizedTrendText(trend) {
            const defaultTitle = t('No Title Available');
            const defaultDescription = t('No Description Available');
            let titleText = defaultTitle;
            let descriptionText = defaultDescription;
            let indicator = '';

            if (currentLanguage === 'vi') {
                if (trend.title_vi) {
                    titleText = trend.title_vi;
                    descriptionText = trend.description_vi || trend.description_en || defaultDescription;
                } else if (trend.title_en) {
                    titleText = trend.title_en;
                    descriptionText = trend.description_en || defaultDescription;
                    indicator = ' [EN]';
                }
            } else { // currentLanguage === 'en'
                if (trend.title_en) {
                    titleText = trend.title_en;
                    descriptionText = trend.description_en || trend.description_vi || defaultDescription;
                } else if (trend.title_vi) {
                    titleText = trend.title_vi;
                    descriptionText = trend.description_vi || defaultDescription;
                    indicator = ' [VI]';
                }
            }
            return { title: titleText + indicator, description: descriptionText };
        }

        function truncateText(text = '', maxLength = 180) {
            if (!text || text.length <= maxLength) return text;
            const cut = text.slice(0, maxLength);
            return cut.slice(0, cut.lastIndexOf(' ', maxLength) || maxLength) + '…';
        }

        function makeTrendKey(trend) { 
            const id = trend.id; 
            return `${id}|${getLocalizedTrendText(trend).title || ''}|${trend.source || ''}`.toLowerCase(); 
        }
        function loadSeenTrends() { try { return JSON.parse(localStorage.getItem('seenTrends') || '[]'); } catch { return []; } }
        function saveSeenTrendKey(key) { try { const seen = new Set(loadSeenTrends()); if (!seen.has(key)) localStorage.setItem('seenTrends', JSON.stringify([...seen, key])); } catch {} }

        function applyTrendOrdering() {
            const seenKeys = new Set(loadSeenTrends());
            const unseen = [];
            const seen = [];
            masterTrendsList.forEach(trendItem => (seenKeys.has(makeTrendKey(trendItem)) ? seen : unseen).push(trendItem));
            masterTrendsList = [...shuffleArray(unseen), ...seen];
        }

        function shuffleArray(arr) {
            for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; }
            return arr;
        }

        function generateChartDataFromScore(score, baseMetric = 500) {
            const growthFactor = (score - 50) / 500;
            let historicalData = [baseMetric * 0.4, baseMetric * 0.7, baseMetric * 0.9, baseMetric].map(v => Math.round(v));
            let futureProjection = [];
            let lastValue = baseMetric;
            let next1d = lastValue * (1 + growthFactor * 0.2 + (Math.random() - 0.5) * 0.05);
            futureProjection.push(Math.max(0, Math.round(next1d)));
            let next4d = next1d * (1 + growthFactor * 0.1 + (Math.random() - 0.5) * 0.05);
            futureProjection.push(Math.max(0, Math.round(next4d)));
            let next7d = next4d * (1 + growthFactor * 0.05 + (Math.random() - 0.5) * 0.05);
            futureProjection.push(Math.max(0, Math.round(next7d)));
            return { historicalData, futureProjection };
        }

        function getColorPalette(count) {
            const base = [{ stroke: '#A100FF' }, { stroke: '#00C8FF' }, { stroke: '#00E696' }, { stroke: '#FFB400' }, { stroke: '#FF6384' }];
            while (base.length < count) base.push({ stroke: `hsl(${Math.random() * 360}, 90%, 60%)` });
            return base;
        }

        function formatNumber(n) { if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M'; if (n >= 1e3) return (n / 1e3).toFixed(1) + 'K'; return String(n); }

        async function checkAIStatus() {
            try {
                const response = await fetch("/.netlify/functions/analyze-trend", { method: 'GET' });
                const statusIndicator = document.getElementById('ai-status-indicator');
                const statusText = document.getElementById('ai-status-text');
                const isOnline = response.ok;
                if (statusIndicator) statusIndicator.classList.toggle('online', isOnline);
                if (statusIndicator) statusIndicator.classList.toggle('offline', !isOnline);
                if (statusText) statusText.textContent = t(isOnline ? 'AI: Ready' : 'AI: Unavailable');
            } catch (error) {
                const statusIndicator = document.getElementById('ai-status-indicator');
                const statusText = document.getElementById('ai-status-text');
                if (statusIndicator) statusIndicator.className = 'ai-status-indicator offline';
                if (statusText) statusText.textContent = t('AI: Connection error');
                console.error('AI Status Check Failed:', error);
            }
        }

        function updateActiveNav(activeView) {
            document.querySelectorAll('#main-nav a').forEach(a => a.classList.remove('active-link'));
            if (activeView === 'main') { if (DOM.navTopTrends) DOM.navTopTrends.classList.add('active-link'); }
            else if (activeView === 'forU') { if (DOM.navForU && DOM.navForU.querySelector('a')) DOM.navForU.querySelector('a').classList.add('active-link'); }
            else if (activeView === 'trendingBoard') { if (DOM.navTrendingBoard) DOM.navTrendingBoard.classList.add('active-link'); }
            else if (activeView === 'about') { if (DOM.navAbout) DOM.navAbout.classList.add('active-link'); }
        }

        // NEW: Function to open the AI Insight modal
        async function openAIInsightModal(trend, analysisType) {
            let titleIcon = '';
            let titleKey = '';

            // Bước 1: Chọn icon và key dịch thuật phù hợp với loại phân tích
            if (analysisType === 'prediction') {
                titleIcon = '🔮 ';
                titleKey = 'AI Analysis Summary for'; // Key này trong translations được dịch thành "Dự đoán AI cho"
            } else if (analysisType === 'detailed') {
                titleIcon = '🔍 ';
                titleKey = 'AI Deep Dive for';
            } else {
                // Fallback cho 'summary' hoặc các loại khác không xác định
                titleIcon = '💡 ';
                titleKey = 'AI Insight for';
            }
            
            const { title: localizedTrendTitle } = getLocalizedTrendText(trend);
            const modalTitleEl = document.getElementById('ai-insight-title');
            if(modalTitleEl) {
                // Cập nhật tiêu đề modal với icon và văn bản đã dịch
                modalTitleEl.textContent = `${titleIcon} ${t(titleKey)} "${truncateText(localizedTrendTitle, 20)}"`;
            }
            
            const modalBody = document.getElementById('ai-insight-body');
            if (!modalBody) {
                console.error("AI Insight modal body not found!");
                return;
            }
            
            // Bước 2: Hiển thị trạng thái tải và mở modal
            modalBody.classList.remove('error-message');
            modalBody.innerHTML = `<div style="display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 200px;">
                                       <div class="loading-spinner"></div>
                                       <p style="text-align:center; margin-top:1rem;">${t('Analyzing trend...')}</p>
                                   </div>`;
            openModal('ai-insight-modal');
            closeModal('trend-overview-modal'); // Đóng modal tổng quan nếu nó đang mở

            // Bước 3: Gọi API back-end để lấy phân tích
            try {
                // Lấy dữ liệu thô từ server
                let rawData = await analyzeTrendSecurely(trend, analysisType);
                
                // **** BẮT ĐẦU SỬA LỖI ****
                // Dọn dẹp các khối mã Markdown mà AI có thể trả về
                if (typeof rawData === 'string') {
                    // Loại bỏ ```html ở đầu và ``` ở cuối, cùng với các khoảng trắng
                    rawData = rawData.trim().replace(/^```html\s*/, '').replace(/\s*```$/, '').trim();
                }
                // **** KẾT THÚC SỬA LỖI ****
                
                // Bước 4: Hiển thị kết quả thành công
                // DOMPurify sẽ đảm bảo HTML còn lại là an toàn trước khi render
                modalBody.innerHTML = DOMPurify.sanitize(rawData, { USE_PROFILES: { html: true } });

            } catch (err) {
                // Bước 5: Hiển thị thông báo lỗi nếu API thất bại
                console.error("AI analysis failed:", err);
                if (modalBody) {
                    modalBody.classList.add('error-message');
                    modalBody.innerHTML = `<div style="text-align: center;">
                                               <p>${t('Unable to analyze trend.')}</p>
                                               <small style="color: var(--text-muted-color);">${DOMPurify.sanitize(err.message)}</small>
                                           </div>`;
                }
            }
        }
        // NEW: Function to open the trend overview modal
        function openTrendOverviewModal(trend) {
            // No longer need login check here, as user is always 'work'
            if (!trend) {
                console.error("No trend data provided for overview modal.");
                return;
            }
           
            DOM.trendOverviewBody.innerHTML = createTrendCardContent(trend);
            openModal('trend-overview-modal');
            
            DOM.trendOverviewBody.dataset.currentTrendId = trend.id; // Store current trend ID for easy access
        }


        // --- Trending Board specific functions ---

        function isTrendRelevantForTimeframe(trend, timeframe) {
            if (!trend || !trend.date) return false;
            const trendDate = new Date(trend.date);
            const now = new Date();
            let cutoffDate = new Date(now);

            switch (timeframe) {
                case '1h': cutoffDate.setHours(now.getHours() - 1); break;
                case '6h': cutoffDate.setHours(now.getHours() - 6); break;
                case '24h': cutoffDate.setHours(now.getHours() - 24); break;
                case '3d': cutoffDate.setDate(now.getDate() - 3); break;
                case '7d': cutoffDate.setDate(now.getDate() - 7); break;
                case '1m': cutoffDate.setDate(now.getDate() - 30); break;
                case '3m': cutoffDate.setDate(now.getDate() - 90); break;
                case '12m': cutoffDate.setFullYear(now.getFullYear() - 1); break;
                default: return true;
            }
            return trendDate >= cutoffDate;
        }
        
        function generateChartLabels(timeframe) {
            const now = new Date();
            const labels = [];
            const dayOptions = { day: 'numeric', month: 'short' };
            const hourOptions = { hour: 'numeric', minute: '2-digit' };

            switch (timeframe) {
                case '1h': for (let i = 5; i >= 0; i--) { const d = new Date(now); d.setMinutes(now.getMinutes() - i * 10); labels.push(d.toLocaleTimeString(currentLanguage, hourOptions)); } break;
                case '6h': for (let i = 5; i >= 0; i--) { const d = new Date(now); d.setHours(now.getHours() - i); labels.push(d.toLocaleTimeString(currentLanguage, hourOptions)); } break;
                case '24h': for (let i = 5; i >= 0; i--) { const d = new Date(now); d.setHours(now.getHours() - i * 4); labels.push(d.toLocaleTimeString(currentLanguage, hourOptions)); } break;
                case '3d': for (let i = 2; i >= 0; i--) { const d = new Date(now); d.setDate(now.getDate() + i - 2); labels.push(d.toLocaleDateString(currentLanguage, dayOptions)); } break;
                case '7d': for (let i = 6; i >= 0; i--) { const d = new Date(now); d.setDate(now.getDate() - i); labels.push(d.toLocaleDateString(currentLanguage, dayOptions)); } break;
                case '1m': for (let i = 29; i >= 0; i -= 5) { const d = new Date(now); d.setDate(now.getDate() - i); labels.push(d.toLocaleDateString(currentLanguage, dayOptions)); } break;
                case '3m': for (let i = 89; i >= 0; i -= 15) { const d = new Date(now); d.setDate(now.getDate() - i); labels.push(d.toLocaleDateString(currentLanguage, dayOptions)); } break;
                case '12m': for (let i = 11; i >= 0; i--) { const d = new Date(now); d.setMonth(now.getMonth() - i); labels.push(d.toLocaleDateString(currentLanguage, { month: 'short', year: '2-digit' })); } break;
                case 'next3d': for (let i = 0; i <= 3; i++) { const d = new Date(now); d.setDate(now.getDate() + i); labels.push(d.toLocaleDateString(currentLanguage, dayOptions)); } break;
                case 'next5d': for (let i = 0; i <= 5; i++) { const d = new Date(now); d.setDate(now.getDate() + i); labels.push(d.toLocaleDateString(currentLanguage, dayOptions)); } break;
                case 'next7d': for (let i = 0; i <= 7; i++) { const d = new Date(now); d.setDate(now.getDate() + i); labels.push(d.toLocaleDateString(currentLanguage, dayOptions)); } break;
                default: return generateChartLabels('7d');
            }
            return labels;
        }
        
        function generateSeriesForTimeframe(trend, labels, timeframe) {
            // --- PHẦN 1: Xử lý "trend ảo" từ Google Trends ---
            if (trend.isVirtual && trend.interestData) {
                console.log("-> Generating series for VIRTUAL trend:", trend.title_en);
                const series = new Array(labels.length).fill(null); // Bắt đầu bằng null để nội suy
                const interestMap = new Map();

                // Bước 1: Map dữ liệu từ Google Trends (có timestamp) vào một Map với key là ngày đã định dạng
                trend.interestData.forEach(point => {
                    const date = new Date(point.time * 1000); // Google Trends dùng Unix timestamp (giây), cần *1000
                    // Định dạng ngày này phải khớp hệt với định dạng của `labels` được tạo bởi generateChartLabels
                    const formattedDate = date.toLocaleDateString(currentLanguage, { day: 'numeric', month: 'short' });
                    interestMap.set(formattedDate, point.value[0]); // point.value là mảng, lấy phần tử đầu tiên
                });

                // Bước 2: Điền dữ liệu vào mảng `series` dựa trên sự trùng khớp của label
                labels.forEach((label, index) => {
                    if (interestMap.has(label)) {
                        // Nhân giá trị (0-100) với một hệ số để nó có thang đo tương đương các trend thật
                        series[index] = interestMap.get(label) * 1000;
                    }
                });

                // Bước 3: Nội suy (interpolate) các giá trị null để đường kẻ được liền mạch, không bị đứt gãy
                for (let i = 0; i < series.length; i++) {
                    if (series[i] === null) {
                        let prev = i - 1;
                        let next = i + 1;
                        // Tìm điểm có dữ liệu gần nhất phía trước
                        while (prev >= 0 && series[prev] === null) {
                            prev--;
                        }
                        // Tìm điểm có dữ liệu gần nhất phía sau
                        while (next < series.length && series[next] === null) {
                            next++;
                        }
                        
                        const prevVal = prev < 0 ? 0 : series[prev];
                        const nextVal = next >= series.length ? prevVal : series[next];
                        
                        // Nếu có cả điểm trước và sau, thực hiện nội suy tuyến tính
                        if (prev >= 0 && next < series.length) {
                             const slope = (nextVal - prevVal) / (next - prev);
                             series[i] = Math.round(prevVal + slope * (i - prev));
                        } else {
                            // Nếu ở đầu hoặc cuối mảng, chỉ cần lấy giá trị gần nhất
                            series[i] = prevVal;
                        }
                    }
                }
                
                return series;
            }

            // --- PHẦN 2: Xử lý trend thông thường (từ NewsAPI/RSS) ---
            const series = new Array(labels.length).fill(0);
            const trendDate = new Date(trend.date || Date.now());
            trendDate.setHours(0, 0, 0, 0);
            const peakMetric = getCombinedMetric(trend);

            const now = new Date();
            now.setHours(0, 0, 0, 0);

            labels.forEach((label, index) => {
                let currentLabelDate;
                // Tính toán ngày/giờ tương ứng với mỗi label trên biểu đồ
                if (timeframe.includes('h')) {
                    let datePart = new Date(now); 
                    const offsetMinutes = (labels.length - 1 - index) * (timeframe === '1h' ? 10 : (timeframe === '6h' ? 60 : 240));
                    datePart.setMinutes(now.getMinutes() - offsetMinutes);
                    currentLabelDate = new Date(datePart.getFullYear(), datePart.getMonth(), datePart.getDate(), datePart.getHours());
                } else {
                    let datePart = new Date(now);
                    let daysOffset;
                    if (timeframe.startsWith('next')) {
                        daysOffset = index; 
                        datePart.setDate(now.getDate() + daysOffset);
                    } else if (timeframe === '3d') {
                        daysOffset = (labels.length - 1 - index);
                        datePart.setDate(now.getDate() - daysOffset);
                    } else if (timeframe === '7d') {
                        daysOffset = (labels.length - 1 - index);
                        datePart.setDate(now.getDate() - daysOffset);
                    } else if (timeframe === '1m') {
                        daysOffset = Math.round((labels.length - 1 - index) * (30 / (labels.length - 1)));
                        datePart.setDate(now.getDate() - daysOffset);
                    } else if (timeframe === '3m') {
                        daysOffset = Math.round((labels.length - 1 - index) * (90 / (labels.length - 1)));
                        datePart.setDate(now.getDate() - daysOffset);
                    } else if (timeframe === '12m') {
                        const monthsOffset = (labels.length - 1 - index);
                        datePart.setMonth(now.getMonth() - monthsOffset);
                    }
                    currentLabelDate = new Date(datePart.getFullYear(), datePart.getMonth(), datePart.getDate());
                }
                currentLabelDate.setHours(0, 0, 0, 0);

                const isPredictive = timeframe.startsWith('next');

                // Nếu là biểu đồ quá khứ và label hiện tại ở trước ngày trend xuất hiện, giá trị là 0
                if (!isPredictive && currentLabelDate < trendDate) {
                    series[index] = 0;
                    return;
                }

                let timeDiffRelevantDays = isPredictive ?
                    (currentLabelDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24) :
                    (currentLabelDate.getTime() - trendDate.getTime()) / (1000 * 60 * 60 * 24);

                let rawValue = 0;
                let hotnessMultiplier = 1 + (trend.hotnessScore || 0) * 5;

                // Mô phỏng dữ liệu dự đoán
                if (isPredictive) {
                    const daysIntoFuture = timeDiffRelevantDays;
                    const initialHotness = peakMetric * (1 + (trend.hotnessScore || 0) * 0.5);
                    const growthFactor = 0.8;
                    const decayAfterPeak = 0.1;
                    const maxGrowthDays = 2; 
                    
                    if (daysIntoFuture <= maxGrowthDays) {
                        rawValue = initialHotness * (1 + (growthFactor * daysIntoFuture / maxGrowthDays));
                    } else {
                        rawValue = initialHotness * (1 + growthFactor) * Math.exp(-decayAfterPeak * (daysIntoFuture - maxGrowthDays));
                    }
                    rawValue *= (1 + (Math.random() - 0.5) * 0.2); // Thêm nhiễu
                    series[index] = Math.max(Math.round(peakMetric * 0.2), Math.round(rawValue));

                } else { // Mô phỏng dữ liệu quá khứ
                    let decayRate = 0.05;
                    let peakShiftDays = 3; 
                                        
                    if (timeframe === '7d' || timeframe === '3d' || timeframe.includes('h')) {
                        decayRate = 0.8; 
                        peakShiftDays = 1; 
                    } else if (timeframe === '1m' || timeframe === '3m') {
                        decayRate = 0.3; 
                        peakShiftDays = 3; 
                    } else { // 12m
                        decayRate = 0.05; 
                        peakShiftDays = 10; 
                    }
                    
                    const timeRelativeToPeak = timeDiffRelevantDays - peakShiftDays;
                    // Dùng công thức mô phỏng đường cong hình chuông (Gaussian-like)
                    rawValue = peakMetric * hotnessMultiplier * Math.exp(-decayRate * Math.pow(timeRelativeToPeak, 2) / (peakShiftDays * peakShiftDays));
                    rawValue = rawValue * (1 + (Math.random() - 0.5) * 0.2); // Thêm nhiễu
                    series[index] = Math.max(0, Math.round(rawValue));
                }
            });

            return series;
        }

        async function renderTBDashboard(trendsForLeaderboard) {
            const topics = trendsForLeaderboard.filter(trend => trend.type === 'topic').sort((a,b) => b.hotnessScore - a.hotnessScore).slice(0, 5);
            const queries = trendsForLeaderboard.filter(trend => trend.type === 'query').sort((a,b) => b.hotnessScore - a.hotnessScore).slice(0, 5);

            const tbTopicList = document.getElementById('tb-topic-list');
            const tbQueryList = document.getElementById('tb-query-list');

            if (tbTopicList) {
                if (topics.length === 0) {
                    tbTopicList.innerHTML = `<p class="modal-body" style="text-align: center;">${t('No trends found.')}</p>`;
                } else {
                    tbTopicList.innerHTML = `<ol>${topics.map((trendItem, i) => `<li data-trend-id="${trendItem.id}"><span class="rank">${i+1}</span><span class="term">${getLocalizedTrendText(trendItem).title}</span><span class="growth">${t('Rising')}</span></li>`).join('')}</ol>`;
                }
            }
            
            if (tbQueryList) {
                if (queries.length === 0) {
                    tbQueryList.innerHTML = `<p class="modal-body" style="text-align: center;">${t('No trends found.')}</p>`;
                } else {
                    tbQueryList.innerHTML = `<ol>${queries.map((trendItem, i) => `<li data-trend-id="${trendItem.id}"><span class="rank">${i+1}</span><span class="term">${getLocalizedTrendText(trendItem).title}</span><span class="growth">+${Math.floor(Math.random() * 4000)}%</span></li>`).join('')}</ol>`;
                }
            }
        }

        async function renderUserTrendsChart(timeframe) {
            const chartContainer = document.getElementById('user-trends-chart-container');
            const chartTitleEl = document.getElementById('user-trends-chart-title');
            const canvas = document.getElementById('user-trends-chart');

            if (!chartContainer || !chartTitleEl || !canvas) {
                console.error("User trends chart elements not found.");
                return;
            }

            // Chỉ hiển thị biểu đồ này nếu người dùng có sở thích hoặc đã follow trend
            if (!user.hasSetPreferences && user.followedTrends.length === 0) {
                chartContainer.classList.add('hidden');
                return;
            }

            if (userTrendsChart) {
                userTrendsChart.destroy();
            }

            // Lọc ra các trend liên quan đến người dùng (theo sở thích hoặc đã follow)
            let userRelevantTrends = masterTrendsList.filter(trendItem =>
                isTrendRelevantForTimeframe(trendItem, timeframe) && 
                (user.followedTrends.includes(trendItem.id) ||
                (user.preferences.length > 0 && user.preferences.includes(trendItem.category)))
            );

            // Loại bỏ các trend trùng lặp và sắp xếp theo độ hot
            userRelevantTrends = Array.from(new Set(userRelevantTrends.map(t => t.id)))
                .map(id => masterTrendsList.find(t => t.id === id)) 
                .filter(Boolean)
                .sort((a, b) => b.hotnessScore - a.hotnessScore);

            // Lấy 5 trend hot nhất để vẽ
            const trendsToChart = userRelevantTrends.slice(0, 5);

            if (trendsToChart.length === 0) {
                chartContainer.classList.add('hidden');
                return;
            }

            chartContainer.classList.remove('hidden');
            chartTitleEl.textContent = t('Your Favorite Trends - Interest Over Time');

            const labels = generateChartLabels(timeframe);
            const palette = getColorPalette(trendsToChart.length);

            const datasets = trendsToChart.map((trendItem, idx) => {
                const color = palette[idx % palette.length].stroke;
                return {
                    label: truncateText(getLocalizedTrendText(trendItem).title, 30),
                    data: generateSeriesForTimeframe(trendItem, labels, timeframe),
                    borderColor: color,
                    backgroundColor: (context) => {
                        const {ctx, chartArea} = context.chart;
                        if (!chartArea) return null;
                        let transparentColorEnd = color.startsWith('hsl') ? color.replace('hsl', 'hsla').replace(')', ', 0.25)') : `${color}40`;
                        const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
                        gradient.addColorStop(0, 'rgba(161, 0, 255, 0)');
                        gradient.addColorStop(1, transparentColorEnd); 
                        return gradient;
                    },
                    tension: 0.4, 
                    fill: true, 
                    pointRadius: 1, 
                    pointBackgroundColor: color,
                    pointHoverRadius: 6, 
                    pointHoverBorderWidth: 2, 
                    pointHoverBorderColor: 'white',
                    trendId: trendItem.id
                };
            });
            
            const allDataPoints = datasets.flatMap(ds => ds.data.filter(p => p !== null));
            const maxDataValue = Math.max(...allDataPoints, 0);

            userTrendsChart = new Chart(canvas.getContext('2d'), {
                type: 'line', 
                data: { labels, datasets },
                options: { // **** THAY THẾ TOÀN BỘ KHỐI NÀY ****
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { 
                            position: 'bottom',
                            align: 'center',
                            labels: { color: '#8a8da0', usePointStyle: true, boxWidth: 8, padding: 20 },
                            onHover: (event) => { event.native.target.style.cursor = 'pointer'; },
                            onLeave: (event) => { event.native.target.style.cursor = 'default'; },
                            onClick: (e, legendItem, legend) => {
                                const index = legendItem.datasetIndex;
                                const trendIdFromLegend = legend.chart.data.datasets[index].trendId;
                                if (trendIdFromLegend) {
                                    const trend = masterTrendsList.find(t => t.id === trendIdFromLegend);
                                    if (trend) openTrendOverviewModal(trend);
                                }
                            }
                        },
                        tooltip: {
                            enabled: true,
                            backgroundColor: 'var(--surface-color)',
                            titleColor: 'var(--text-color)',
                            titleFont: { weight: '600', size: 14 },
                            bodyColor: 'var(--text-color)',
                            borderColor: 'var(--border-color)',
                            borderWidth: 1,
                            padding: 12,
                            displayColors: true,
                            boxPadding: 4,
                            filter: function (tooltipItem) {
                                return tooltipItem.raw > 0;
                            },
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.raw;
                                    return `${label}: ${formatNumber(value)} Engagement`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            grid: { display: false }, 
                            ticks: { color: '#8a8da0' } 
                        },
                        y: { 
                            grid: { color: 'rgba(255, 255, 255, 0.05)'},
                            ticks: { color: '#8a8da0', callback: (v) => formatNumber(v) }, 
                            beginAtZero: true, 
                            min: 0,
                            suggestedMax: maxDataValue * 1.2 || 1000,
                        }
                    }
                }
            });
        }
        
        async function createHotTrendsChart(newSearchTerm = null, compareTerm = null) {
            const canvas = document.getElementById('hot-trends-chart');
            const clearSearchBtn = document.getElementById('tb-clear-search-btn');
            const searchDetailsWrapper = document.getElementById('tb-search-details-wrapper');
            const comparisonContainer = document.getElementById('tb-comparison-table-container');
            const chartTitleEl = document.getElementById('tb-chart-title');
            
            if (!canvas) { 
                console.error("Chart canvas 'hot-trends-chart' not found!");
                return; 
            }
            if (hotTrendsChart) {
                hotTrendsChart.destroy();
            }

            if (chartTitleEl && !chartTitleEl.dataset.listenerAttached) {
                chartTitleEl.dataset.listenerAttached = 'true';
                chartTitleEl.style.cursor = 'pointer';
                chartTitleEl.addEventListener('click', () => {
                    document.getElementById('explanation-title').textContent = t('What is Engagement Score?');
                    document.getElementById('explanation-body').textContent = t('Engagement Score Explanation');
                    openModal('explanation-modal');
                });
            }

            if (newSearchTerm) {
                const term = newSearchTerm.trim();
                if (term && !user.tbSearchTerms.includes(term)) user.tbSearchTerms.push(term);
            }
            if (compareTerm) {
                const term = compareTerm.trim();
                if (term && !user.tbSearchTerms.includes(term)) user.tbSearchTerms.push(term);
            }

            const isInSearchMode = user.tbSearchTerms.length > 0;
            const searchTermsChanged = JSON.stringify(user.tbSearchTerms) !== JSON.stringify(lastRenderedSearchTerms);

            if (DOM.tbSearchChipsContainer) {
                DOM.tbSearchChipsContainer.innerHTML = user.tbSearchTerms.map(term => `<span class="tb-search-chip">${truncateText(term, 20)}<button class="tb-search-chip-remove" data-term="${term}">&times;</button></span>`).join('');
                DOM.tbSearchChipsContainer.classList.toggle('hidden', !isInSearchMode);
            }
            
            if (clearSearchBtn) {
                clearSearchBtn.classList.toggle('hidden', !isInSearchMode);
            }
            
            if (searchTermsChanged) {
                if (searchDetailsWrapper) {
                    searchDetailsWrapper.innerHTML = '';
                    searchDetailsWrapper.classList.add('hidden');
                }
                if (comparisonContainer) {
                    comparisonContainer.classList.add('hidden');
                }
                currentSearchResults = [];
            }

            let datasets = [];
            let chartLabels = [];

            if (isInSearchMode) {
                // --- CHẾ ĐỘ TÌM KIẾM ---
                if (DOM.tbDefaultView) DOM.tbDefaultView.classList.add('hidden');
                if (chartTitleEl) chartTitleEl.innerHTML = `<div class="loading-spinner" style="display: inline-block; vertical-align: middle; margin-right: 10px;"></div> ${t('Searching for')}...`;
                
                try {
                    const currentTimeframe = DOM.tbCustomTimeframeSelect.value;
                    const currentStatus = DOM.tbStatusSelect.value;
                    const modeParam = currentStatus === 'predictive' ? '&mode=predictive' : '';

                    const searchPromises = user.tbSearchTerms.map(term => 
                        fetch(`/.netlify/functions/fetch-trends?searchTerm=${encodeURIComponent(term)}&timeframe=${currentTimeframe}${modeParam}`).then(res => res.json())
                    );
                    const results = await Promise.all(searchPromises);
                    
                    const processedResults = results.map(res => (res.success && res.trends.length > 0) ? res.trends[0] : null).filter(Boolean);

                    // --- LOGIC RENDER CHI TIẾT (Top Articles & Related Queries) ---
                    if (searchTermsChanged) {
                        processedResults.forEach(searchData => {
                            currentSearchResults.push(...searchData.topArticles);
                            const articlesHTML = `
                                <div class="tb-details-panel">
                                    <h4>${t('Top Articles for')} "${searchData.title_en}"</h4>
                                    <ul class="tb-article-list">
                                        ${searchData.topArticles.length > 0
                                            ? searchData.topArticles.map(article => `<li class="tb-article-item" data-trend-id="${article.id}"><div class="tb-article-title">${article.title_en}</div><div class="tb-article-source">${article.submitter}</div></li>`).join('')
                                            : `<li>${t('No articles found.')}</li>`}
                                    </ul>
                                </div>`;
                            const queriesHTML = `
                                <div class="tb-details-panel">
                                    <h4>${t('Related Queries')}</h4>
                                    <ul class="tb-related-list">
                                        ${searchData.relatedQueries.length > 0
                                            ? searchData.relatedQueries.map(q => `<li class="tb-related-item" data-query="${q.query}"><span class="tb-related-query">${q.query}</span><span class="tb-related-value">${q.value > 100 ? `+${q.value}%` : 'Hot'}</span></li>`).join('')
                                            : `<li>${t('No related queries.')}</li>`}
                                    </ul>
                                </div>`;
                            const container = document.createElement('div');
                            container.className = 'tb-search-details-container';
                            container.innerHTML = articlesHTML + queriesHTML;
                            if (searchDetailsWrapper) searchDetailsWrapper.appendChild(container);
                        });

                        if (searchDetailsWrapper && searchDetailsWrapper.innerHTML.trim() !== '') {
                            searchDetailsWrapper.classList.remove('hidden');
                        }
                        
                        lastRenderedSearchTerms = [...user.tbSearchTerms];
                    }

                    const palette = getColorPalette(processedResults.length);
                    
                    // --- LOGIC RENDER BẢNG SO SÁNH (ĐÃ THÊM LẠI) ---
                    if (searchTermsChanged && processedResults.length > 1 && comparisonContainer) {
                        const comparisonBody = document.getElementById('tb-comparison-body');
                        if (comparisonBody) {
                            comparisonBody.innerHTML = '';
                            processedResults.forEach((data, index) => {
                                const row = document.createElement('tr');
                                const color = palette[index % palette.length].stroke;
                                row.innerHTML = `
                                    <td><div class="comparison-term-cell"><span class="term-color-swatch" style="background-color: ${color};"></span>${data.title_en}</div></td>
                                    <td class="comparison-value">${formatNumber(data.totalEngagement)}</td>
                                    <td class="comparison-value">${formatNumber(data.peakEngagement)}</td>
                                    <td><span class="comparison-source">${data.submitter}</span></td>
                                `;
                                comparisonBody.appendChild(row);
                            });
                            comparisonContainer.classList.remove('hidden');
                        }
                    }

                    let masterTimeline = new Map();
                    processedResults.forEach(trendData => {
                        if (trendData.timelineData) {
                            trendData.timelineData.forEach(point => {
                                const date = new Date(point.time * 1000);
                                const formattedDate = date.toLocaleDateString(currentLanguage, { day: 'numeric', month: 'short' });
                                if (!masterTimeline.has(point.time)) masterTimeline.set(point.time, { label: formattedDate });
                            });
                        }
                    });
                    
                    const sortedTimeline = Array.from(masterTimeline.entries()).sort((a, b) => a[0] - b[0]);
                    chartLabels = sortedTimeline.map(entry => entry[1].label);

                    datasets = processedResults.flatMap((trendData, i) => {
                        const dataMap = new Map(trendData.timelineData.map(p => [new Date(p.time * 1000).toLocaleDateString(currentLanguage, { day: 'numeric', month: 'short' }), p]));
                        const historicalData = new Array(chartLabels.length).fill(null);
                        const predictionData = new Array(chartLabels.length).fill(null);
                        let lastHistoricalIndex = -1;

                        chartLabels.forEach((label, index) => {
                            if (dataMap.has(label)) {
                                const point = dataMap.get(label);
                                if (point.isPrediction) {
                                    predictionData[index] = point.value[0];
                                } else {
                                    historicalData[index] = point.value[0];
                                    lastHistoricalIndex = index;
                                }
                            }
                        });

                        if (lastHistoricalIndex !== -1 && predictionData.some(p => p !== null)) {
                            predictionData[lastHistoricalIndex] = historicalData[lastHistoricalIndex];
                        }
                        
                        const color = palette[i % palette.length].stroke;
                        const baseDataset = {
                            label: trendData.title_en,
                            borderColor: color,
                            backgroundColor: (context) => {
                                const {ctx, chartArea} = context.chart;
                                if (!chartArea) return null;
                                let transparentColorEnd = color.startsWith('hsl') ? color.replace('hsl', 'hsla').replace(')', ', 0.25)') : `${color}40`;
                                const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
                                gradient.addColorStop(0, 'rgba(161, 0, 255, 0)');
                                gradient.addColorStop(1, transparentColorEnd);
                                return gradient;
                            },
                            tension: 0.4, fill: true, pointRadius: 1, pointBackgroundColor: color,
                            pointHoverRadius: 6, pointHoverBorderWidth: 2, pointHoverBorderColor: 'white',
                            trendId: trendData.id
                        };

                        const datasetsForTerm = [];
                        if (historicalData.some(p => p !== null)) {
                            datasetsForTerm.push({ ...baseDataset, data: historicalData });
                        }
                        if (predictionData.some(p => p !== null)) {
                            datasetsForTerm.push({
                                ...baseDataset,
                                label: `${trendData.title_en} (${t('Predictive')})`,
                                borderDash: [5, 5],
                                data: predictionData,
                                fill: false
                            });
                        }
                        return datasetsForTerm;
                    });
                    
                    if (chartTitleEl) chartTitleEl.textContent = `${t('Search Results')} - ${t('Interest Over Time')}`;
                } catch (error) {
                    console.error("Live search failed:", error);
                    if (chartTitleEl) chartTitleEl.textContent = t('Search failed. Please try again.');
                }
            } else {
                // --- CHẾ ĐỘ DUYỆT MẶC ĐỊNH ---
                lastRenderedSearchTerms = [];
                const status = DOM.tbStatusSelect.value;
                const customTimeframe = DOM.tbCustomTimeframeSelect.value;
                chartLabels = generateChartLabels(customTimeframe);
                
                const titleKeyMap = { hottest: 'Hottest News', latest: 'Latest News', outdated: 'Outdated News', predictive: 'Predictive News' };
                const titleKey = titleKeyMap[status] || (status.charAt(0).toUpperCase() + status.slice(1));
                if (chartTitleEl) chartTitleEl.textContent = `${t(titleKey)} - ${t('Interest Over Time')}`;

                const selectedCategory = DOM.tbCategoryFilter.value;
                const selectedRegion = DOM.tbRegionFilter.value;
                let filteredTrends = masterTrendsList.filter(trend => (selectedRegion === 'global' || trend.region === selectedRegion) && (selectedCategory === 'All' || trend.category === selectedCategory));
                if (status !== 'predictive') filteredTrends = filteredTrends.filter(trend => isTrendRelevantForTimeframe(trend, customTimeframe));
                else filteredTrends = filteredTrends.filter(trend => isTrendRelevantForTimeframe(trend, '7d'));
                if (status === 'outdated') {
                    const cutoffDate = new Date(new Date().setDate(new Date().getDate() - 7));
                    filteredTrends = filteredTrends.filter(trend => new Date(trend.date) < cutoffDate);
                }
                let sortedTrends = [];
                switch (status) {
                    case 'hottest': case 'predictive': sortedTrends = [...filteredTrends].sort((a, b) => b.hotnessScore - a.hotnessScore); break;
                    case 'latest': sortedTrends = [...filteredTrends].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()); break;
                    case 'outdated': sortedTrends = [...filteredTrends].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime()); break;
                    default: sortedTrends = [...filteredTrends].sort((a, b) => b.hotnessScore - a.hotnessScore);
                }
                const trendsToDraw = sortedTrends.slice(0, 5);
                const trendsForLeaderboard = sortedTrends;
                const palette = getColorPalette(trendsToDraw.length || 5);

                datasets = trendsToDraw.map((trend, i) => {
                    const color = palette[i % palette.length].stroke;
                    return {
                        label: truncateText(getLocalizedTrendText(trend).title, 30),
                        data: generateSeriesForTimeframe(trend, chartLabels, customTimeframe),
                        borderColor: color,
                        backgroundColor: (context) => {
                            const {ctx, chartArea} = context.chart;
                            if (!chartArea) return null;
                            let transparentColorEnd = color.startsWith('hsl') ? color.replace('hsl', 'hsla').replace(')', ', 0.25)') : `${color}40`;
                            const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
                            gradient.addColorStop(0, 'rgba(161, 0, 255, 0)');
                            gradient.addColorStop(1, transparentColorEnd);
                            return gradient;
                        },
                        tension: 0.4, fill: true, pointRadius: 1, pointBackgroundColor: color,
                        pointHoverRadius: 6, pointHoverBorderWidth: 2, pointHoverBorderColor: 'white',
                        trendId: trend.id
                    };
                });
                if (DOM.tbDefaultView) DOM.tbDefaultView.classList.remove('hidden');
                renderTBDashboard(trendsForLeaderboard);
            }
            
            const allDataPoints = datasets.flatMap(ds => ds.data.filter(p => p !== null));
            const maxDataValue = Math.max(...allDataPoints, 0);

            if (datasets.length > 0 && allDataPoints.length > 0) {
                hotTrendsChart = new Chart(canvas.getContext('2d'), {
                    type: 'line', 
                    data: { labels: chartLabels, datasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: { mode: 'index', intersect: false },
                        plugins: {
                            legend: { 
                                position: 'bottom', align: 'center',
                                labels: { color: '#8a8da0', usePointStyle: true, boxWidth: 10, padding: 25 },
                                onHover: (event) => { event.native.target.style.cursor = 'pointer'; },
                                onLeave: (event) => { event.native.target.style.cursor = 'default'; },
                                onClick: (e, legendItem, legend) => {
                                    if (user.tbSearchTerms.length > 0) {
                                        console.log("Legend clicked for term:", legendItem.text);
                                        return;
                                    }
                                    const index = legendItem.datasetIndex;
                                    const trendIdFromLegend = legend.chart.data.datasets[index].trendId;
                                    if (trendIdFromLegend) {
                                        const trend = masterTrendsList.find(t => t.id === trendIdFromLegend);
                                        if (trend) openTrendOverviewModal(trend);
                                    }
                                }
                            },
                            tooltip: {
                                enabled: true, backgroundColor: 'var(--surface-color)', titleColor: 'var(--text-color)',
                                titleFont: { weight: '600', size: 14 }, bodyColor: 'var(--text-color)',
                                borderColor: 'var(--border-color)', borderWidth: 1, padding: 12,
                                displayColors: true, boxPadding: 4,
                                filter: (tooltipItem) => tooltipItem.raw > 0,
                                callbacks: {
                                    label: (context) => {
                                        const label = context.dataset.label || '';
                                        const value = context.raw;
                                        return `${label}: ${formatNumber(value)} Engagement`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: { grid: { display: false }, ticks: { color: '#8a8da0' } },
                            y: { 
                                grid: { color: 'rgba(255, 255, 255, 0.05)'},
                                ticks: { color: '#8a8da0', callback: (v) => formatNumber(v) }, 
                                beginAtZero: true,
                                min: 0,
                                suggestedMax: maxDataValue * 1.2 || 1000,
                                title: {
                                    display: true,
                                    text: t('Engagement Score'),
                                    color: 'var(--text-muted-color)',
                                    font: { size: 14, weight: '500' },
                                    padding: { top: 0, left: 0, right: 0, bottom: 10 }
                                }
                            }
                        }
                    }
                });
            } else {
                canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
                if (chartTitleEl) chartTitleEl.textContent = t('No trends found.');
            }
            
            if (isInSearchMode) {
                if (DOM.userTrendsChartContainer) DOM.userTrendsChartContainer.classList.add('hidden');
            } else {
                renderUserTrendsChart(DOM.tbCustomTimeframeSelect.value);
            }
        }
        
        function populateCustomTimeframeOptions(status) {
            const select = DOM.tbCustomTimeframeSelect;
            if (!select) return;
            let options = [], defaultSelection = '';
            switch(status) {
                case 'hottest': case 'latest': case 'outdated':
                    options = [ { value: '1h', textKey: 'Last 1 hour' }, { value: '6h', textKey: 'Last 6 hours' }, { value: '24h', textKey: 'Last 24 hours' }, { value: '3d', textKey: 'Last 3 days' }, { value: '7d', textKey: 'Last 7 days' }, { value: '1m', textKey: 'Last 30 days' }, { value: '3m', textKey: 'Last 90 days' }, { value: '12m', textKey: 'Last 1 year' } ];
                    defaultSelection = '7d';
                    break;
                case 'predictive':
                    options = [ { value: 'next3d', textKey: 'Next 3 days' }, { value: 'next5d', textKey: 'Next 5 days' }, { value: 'next7d', textKey: 'Next 7 days' } ];
                    defaultSelection = 'next7d';
            }
            select.innerHTML = options.map(opt => `<option value="${opt.value}">${t(opt.textKey)}</option>`).join('');
            select.value = currentTrendStatus.customTimeframe;
            if (!select.value || !options.some(opt => opt.value === select.value)) select.value = defaultSelection;
            currentTrendStatus.customTimeframe = select.value;
        }

        function handleInteraction(e) {
            const targetElement = e.target;
            
            // Tìm các phần tử cha có thể tương tác gần nhất
            const trendCard = targetElement.closest('.trend-card');
            const leaderboardItem = targetElement.closest('#tb-topic-list li, #tb-query-list li, #for-u-leaderboards li');
            const articleItem = targetElement.closest('.tb-article-item');
            
            let trendId = null;
            let analysisType = null;
            
            // **** BẮT ĐẦU TÁI CẤU TRÚC LOGIC ƯU TIÊN ****

            // ƯU TIÊN 1: Kiểm tra các nút hành động cụ thể TRƯỚC TIÊN
            if (targetElement.closest('.btn-predict')) {
                trendId = targetElement.closest('[data-trend-id]')?.dataset.trendId;
                analysisType = 'prediction'; // Sử dụng `prediction` như đã định nghĩa
            } else if (targetElement.closest('.analyze-trend-btn')) {
                trendId = targetElement.closest('[data-trend-id]')?.dataset.trendId;
                analysisType = 'detailed';
            } else if (targetElement.closest('.btn-follow')) {
                // Xử lý follow ngay tại đây
                e.preventDefault();
                trendId = targetElement.closest('[data-trend-id]')?.dataset.trendId;
                if (!trendId) return;

                const isFollowed = user.followedTrends.includes(trendId);
                user.followedTrends = isFollowed 
                    ? user.followedTrends.filter(id => id !== trendId) 
                    : [...user.followedTrends, trendId];
                
                document.querySelectorAll(`[data-trend-id="${trendId}"] .btn-follow`).forEach(btn => {
                    btn.classList.toggle('followed', !isFollowed);
                    btn.textContent = !isFollowed ? t('Following') : t('❤️ Follow');
                });
                
                if (currentView === 'forU') generateCategoryLeaderboards('for-u-leaderboards', user.preferences);
                if (currentView === 'trendingBoard') renderUserTrendsChart(DOM.tbCustomTimeframeSelect.value);
                return; // Kết thúc hành động sau khi follow
            }
            // Nút "View Source" là một thẻ <a>, trình duyệt sẽ tự xử lý, không cần can thiệp.

            // ƯU TIÊN 2: Kiểm tra các phần tử điều hướng hoặc mở modal
            else if (targetElement.closest('.trend-title')) {
                trendId = targetElement.closest('.trend-title')?.dataset.trendId;
                analysisType = 'detailed';
            } else if (leaderboardItem) {
                trendId = leaderboardItem.dataset.trendId;
                analysisType = 'detailed';
            } else if (articleItem) {
                e.preventDefault();
                trendId = articleItem.dataset.trendId;
                const trend = currentSearchResults.find(t => t.id === trendId);
                if (trend) openTrendOverviewModal(trend);
                return;
            } else if (targetElement.matches('.tag.hashtag')) {
                e.preventDefault();
                // ... (logic hashtag) ...
                return; 
            } else if (trendCard && !targetElement.closest('a, button')) {
                // ƯU TIÊN 3: CHỈ mở modal nếu click vào nền card (không phải nút hay link)
                e.preventDefault();
                trendId = trendCard.dataset.trendId;
                const trend = masterTrendsList.find(t => t.id === trendId) || currentSearchResults.find(t => t.id === trendId);
                if (trend) openTrendOverviewModal(trend);
                return;
            }

            if (!trendId) return;
            e.preventDefault();

            const trend = currentSearchResults.find(t => t.id === trendId) || masterTrendsList.find(t => t.id === trendId);
            if (!trend) {
                console.error("Trend data not found for ID:", trendId);
                return;
            }

            if (analysisType) { 
                openAIInsightModal(trend, analysisType);
            }
        }

        async function initializeApp() {
                applyTranslations();
                updateLanguageToggleUI();

                if (DOM.mainViewContainer) DOM.mainViewContainer.classList.toggle('hidden', currentView !== 'main');
                if (DOM.forUViewContainer) DOM.forUViewContainer.classList.toggle('hidden', currentView !== 'forU');
                if (DOM.trendingBoardContainer) DOM.trendingBoardContainer.classList.toggle('hidden', currentView !== 'trendingBoard');

                // Initial fetch of master trends list (12 months, global, all categories)
                masterTrendsList = await fetchLiveTrends({ timeframe: '12m', region: 'global', category: 'All' }, false); 
                
                applyTrendOrdering();

                regions = [...new Set(masterTrendsList.map(trendItem => trendItem.region))].filter(Boolean).sort();
                populateRegionsFilter(DOM.mainRegionFilter); // For main view filter
                populateRegionsFilter(DOM.tbRegionFilter); // For TB filter
                categories = [...new Set(masterTrendsList.map(trendItem => trendItem.category))].sort();
                populateCategoryFilters(); // For main view filter buttons and TB filter
                populateMainTimeframeFilter(); // NEW: Populate main timeframe filter
                populateSourceFilter(); // NEW: Populate main source filter
                populateHashtagFilters();
                updateAuthUI();
                checkAIStatus();
                updateActiveNav(currentView);
                updateClearFilterButtonVisibility();

                // CẬP NHẬT: Mở Preferences Modal ngay lập tức nếu chưa thiết lập
                if (!user.hasSetPreferences) {
                    populatePreferenceCheckboxes();
                    openModal('preferences-modal');
                }
                // CẬP NHẬT: Logic điều hướng sau khi preferences modal được xử lý hoặc nếu đã thiết lập
                else if (currentView === 'trendingBoard') { // Nếu đã thiết lập preferences và đang ở trendingBoard
                    const initialTbFilters = {
                        region: DOM.tbRegionFilter ? DOM.tbRegionFilter.value : 'global',
                        category: DOM.tbCategoryFilter ? DOM.tbCategoryFilter.value : 'All',
                    };
                    allTrends = masterTrendsList.filter(trend => 
                        (initialTbFilters.region === 'global' || trend.region === initialTbFilters.region) &&
                        (initialTbFilters.category === 'All' || trend.category === initialTbFilters.category)
                    );
                    currentTrendStatus.status = DOM.tbStatusSelect ? DOM.tbStatusSelect.value : 'hottest';
                    currentTrendStatus.customTimeframe = DOM.tbCustomTimeframeSelect ? DOM.tbCustomTimeframeSelect.value : '7d';
                    populateCustomTimeframeOptions(currentTrendStatus.status); 
                    await createHotTrendsChart();
                } else { // Nếu đã thiết lập preferences và không ở trendingBoard, hiển thị main view
                    displayTrends();
                }


                document.getElementById('loader')?.classList.add('loader-hidden');
            }

            // Event listener for Top Articles
        document.getElementById('tb-search-details-wrapper')?.addEventListener('click', async (e) => {
            const articleItem = e.target.closest('.tb-article-item');
            const relatedItem = e.target.closest('.tb-related-item');

            // Xử lý click vào một bài báo trong Top Articles
            if (articleItem) {
                // Chỉ cần gọi handleInteraction, nó sẽ tự xử lý việc mở modal
                handleInteraction(e);
            }
            
            // Xử lý click vào một cụm từ liên quan
            else if (relatedItem && relatedItem.dataset.query) {
                const query = relatedItem.dataset.query;
                if (query && !user.tbSearchTerms.includes(query)) {
                    await createHotTrendsChart(null, query);
                }
            }
        });
        
        // Update listeners for filters to NOT clear search terms
        if (DOM.tbCategoryFilter) DOM.tbCategoryFilter.addEventListener('change', () => createHotTrendsChart());
        if (DOM.tbRegionFilter) DOM.tbRegionFilter.addEventListener('change', () => createHotTrendsChart());
        if (DOM.tbStatusSelect) DOM.tbStatusSelect.addEventListener('change', () => {
            currentTrendStatus.status = DOM.tbStatusSelect.value;
            populateCustomTimeframeOptions(currentTrendStatus.status);
            createHotTrendsChart();
        });
        if (DOM.tbCustomTimeframeSelect) DOM.tbCustomTimeframeSelect.addEventListener('change', () => {
            currentTrendStatus.customTimeframe = DOM.tbCustomTimeframeSelect.value;
            createHotTrendsChart();
        });

        // Clear search button listener
        document.getElementById('tb-clear-search-btn')?.addEventListener('click', () => {
            user.tbSearchTerms = [];
            createHotTrendsChart();
        });

            if (DOM.hamburgerMenu) DOM.hamburgerMenu.addEventListener('click', () => { if (DOM.mainNav) DOM.mainNav.classList.toggle('nav-active'); });
            if (DOM.logo) DOM.logo.addEventListener('click', (e) => { e.preventDefault(); switchView('main'); }); // Ngăn chặn refresh
            if (DOM.navTopTrends) DOM.navTopTrends.addEventListener('click', (e) => { e.preventDefault(); switchView('main'); });
            if (DOM.navForU) DOM.navForU.addEventListener('click', (e) => { e.preventDefault(); switchView('forU'); });
            // REMOVED: signInBtn event listener
            // if (DOM.signInBtn) DOM.signInBtn.addEventListener('click', () => openModal('login-choice-modal'));
            if (DOM.userEmailBtn) DOM.userEmailBtn.addEventListener('click', () => { if (DOM.userDropdown) DOM.userDropdown.classList.toggle('show'); });
            if (DOM.dropdownSignOut) DOM.dropdownSignOut.addEventListener('click', (e) => {
                e.preventDefault(); // Ngăn chặn hành vi mặc định
                // CẬP NHẬT: Sign Out sẽ reset user về trạng thái ban đầu (đã đăng nhập, chưa thiết lập preferences)
                user = { isLoggedIn: true, email: 'guest@trendpulse.com', accountType: 'work', preferences: [], hasSetPreferences: false, followedTrends: [], tbSearchTerms: [] };
                localStorage.removeItem('userPreferences'); // Xóa preferences đã lưu
                localStorage.removeItem('userHasSetPreferences'); // Xóa trạng thái đã thiết lập
                updateAuthUI();
                if (DOM.userDropdown) DOM.userDropdown.classList.remove('show');
                switchView('main'); // Chuyển về main view
                populatePreferenceCheckboxes(); // Hiển thị lại preferences modal
                openModal('preferences-modal');
            });

            if (DOM.navAbout) DOM.navAbout.addEventListener('click', (e) => { e.preventDefault(); openModal('about-modal'); updateActiveNav('about'); });
            if (DOM.navTrendingBoard) DOM.navTrendingBoard.addEventListener('click', (e) => { e.preventDefault(); /* Không cần kiểm tra login/premium nữa */ switchView('trendingBoard'); });
            // REMOVED: premium-login-btn, login-google-btn, login-work-btn event listeners
            document.getElementById('premium-login-btn')?.addEventListener('click', (e) => { e.preventDefault(); closeModal('premium-modal'); /* openModal('login-choice-modal'); */ }); // Nút này bây giờ có thể vô tác dụng hoặc cần định tuyến lại
            DOM.modalCloses.forEach(btn => btn.addEventListener('click', () => {
                closeModal(btn.closest('.modal-overlay').id);
                const modalId = btn.closest('.modal-overlay').id;
                if (modalId !== 'about-modal') {
                    updateActiveNav(currentView);
                }
            }));

            if (DOM.loadMoreBtn) DOM.loadMoreBtn.addEventListener('click', loadMoreTrends);
            if (DOM.forULoadMoreBtn) DOM.forULoadMoreBtn.addEventListener('click', loadMoreTrends);
            if (DOM.savePreferencesBtn) DOM.savePreferencesBtn.addEventListener('click', () => {
                user.preferences = [...document.querySelectorAll('#preferences-grid input:checked')].map(cb => cb.value);
                user.hasSetPreferences = true;
                localStorage.setItem('userPreferences', JSON.stringify(user.preferences)); // Lưu preferences
                localStorage.setItem('userHasSetPreferences', 'true'); // Lưu trạng thái đã thiết lập
                closeModal('preferences-modal');
                switchView('forU'); // Chuyển đến For U sau khi lưu
            });

            [
                DOM.trendsList, 
                DOM.forUTrendsList, // THÊM LẮNG NGHE CHO FOR U TRENDS LIST
                document.getElementById('for-u-leaderboards'),
                document.getElementById('tb-topic-list'), 
                document.getElementById('tb-query-list')  
            ].forEach(list => {
                if (list) list.addEventListener('click', handleInteraction);
            });

            if (DOM.filterButtonsContainer) DOM.filterButtonsContainer.addEventListener('click', async (e) => {
                if (e.target.matches('.filter-btn')) {
                    currentFilter.type = 'category';
                    currentFilter.value = e.target.dataset.filter;
                    currentFilter.hashtag = '';
                    if (DOM.hashtagList) DOM.hashtagList.querySelectorAll('.hashtag-btn').forEach(btn => btn.classList.remove('active'));

                    updateUIForFilter();
                }
            });
            if (DOM.mainRegionFilter) DOM.mainRegionFilter.addEventListener('change', () => {
                currentFilter.region = DOM.mainRegionFilter.value;
                updateUIForFilter();
            });
            if (DOM.mainTimeframeFilter) DOM.mainTimeframeFilter.addEventListener('change', () => {
                currentFilter.timeframe = DOM.mainTimeframeFilter.value;
                updateUIForFilter();
            });
            if (DOM.mainSourceFilter) DOM.mainSourceFilter.addEventListener('change', () => {
                currentFilter.source = DOM.mainSourceFilter.value;
                updateUIForFilter();
            });

            if (DOM.clearFilterBtn) DOM.clearFilterBtn.addEventListener('click', clearMainViewFilters);

            const debouncedSearch = debounce(async () => {
                currentFilter.searchTerm = DOM.searchInput ? DOM.searchInput.value : '';
                displayedTrends.main = 0;
                displayTrends();
            }, 300);
            if (DOM.searchInput) DOM.searchInput.addEventListener('input', debouncedSearch);

            if (DOM.hashtagList) DOM.hashtagList.addEventListener('click', async (e) => {
                if (e.target.matches('.hashtag-btn')) {
                    const hashtag = e.target.dataset.hashtag;
                    if (currentFilter.hashtag === hashtag) {
                        currentFilter.hashtag = '';
                    } else {
                        currentFilter.hashtag = hashtag;
                    }
                    currentFilter.type = 'hashtag';
                    currentFilter.value = 'All';
                    if (DOM.filterButtonsContainer) DOM.filterButtonsContainer.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));

                    displayedTrends.main = 0;
                    displayTrends();
                    updateUIForFilter();
                }
            });

            if (DOM.tbSearchInput) DOM.tbSearchInput.addEventListener('keypress', async function(e) {
                if (e.key === 'Enter' && this.value.trim() !== '') {
                    await createHotTrendsChart(this.value.trim());
                    this.value = '';
                }
            });

            if (DOM.tbCompareInput) DOM.tbCompareInput.addEventListener('keypress', async function(e) {
                if (e.key === 'Enter' && this.value.trim() !== '') {
                    await createHotTrendsChart(null, this.value.trim());
                    this.value = '';
                }
            });

            if (DOM.tbSearchChipsContainer) DOM.tbSearchChipsContainer.addEventListener('click', async function(e) {
                if (e.target.classList.contains('tb-search-chip-remove')) {
                    const termToRemove = e.target.dataset.term;
                    user.tbSearchTerms = user.tbSearchTerms.filter(term => term !== termToRemove);
                    await createHotTrendsChart();
                }
            });

            if (DOM.tbCategoryFilter) DOM.tbCategoryFilter.addEventListener('change', () => createHotTrendsChart());
            if (DOM.tbRegionFilter) DOM.tbRegionFilter.addEventListener('change', () => createHotTrendsChart());
            
            if (DOM.tbStatusSelect) DOM.tbStatusSelect.addEventListener('change', () => {
                currentTrendStatus.status = DOM.tbStatusSelect.value;
                populateCustomTimeframeOptions(currentTrendStatus.status);
                createHotTrendsChart();
            });
            if (DOM.tbCustomTimeframeSelect) DOM.tbCustomTimeframeSelect.addEventListener('change', () => {
                currentTrendStatus.customTimeframe = DOM.tbCustomTimeframeSelect.value;
                createHotTrendsChart();
            });

            document.addEventListener('click', (e) => {
                if (DOM.userMenu && DOM.userDropdown && !DOM.userMenu.contains(e.target)) {
                    DOM.userDropdown.classList.remove('show');
                }
                if (DOM.mainNav && DOM.hamburgerMenu && DOM.mainNav.classList.contains('nav-active') && !DOM.mainNav.contains(e.target) && !DOM.hamburgerMenu.contains(e.target)) {
                     DOM.hamburgerMenu.click();
                }
            });

            // NEW: Event listener for the new trend overview modal's content
            if (DOM.trendOverviewBody) {
            DOM.trendOverviewBody.addEventListener('click', (e) => {
                // Lấy trendId đã được lưu khi modal mở ra
                const trendId = DOM.trendOverviewBody.dataset.currentTrendId;
                if (!trendId) return;

                const targetElement = e.target;
                
                // Tìm đến element cha có chứa thông tin hành động (nút bấm, tiêu đề, tag)
                const interactiveParent = targetElement.closest('.trend-actions, .trend-card-header, .trend-title, .tag.hashtag');

                // "Trick": Gán tạm thời trendId vào element cha đó.
                // Điều này làm cho các nút bên trong modal hoạt động giống hệt như các nút trên card thông thường.
                if (interactiveParent) {
                    interactiveParent.dataset.trendId = trendId;
                } else if (targetElement.classList.contains('trend-card')) {
                    // Trường hợp click vào nền card bên trong modal
                    targetElement.dataset.trendId = trendId;
                }
                
                // Gọi hàm xử lý tương tác chung, nó sẽ tự biết phải làm gì
                handleInteraction(e);

                // Dọn dẹp dataset tạm thời để tránh ảnh hưởng đến các lần sau (tùy chọn nhưng nên có)
                if (interactiveParent) {
                    delete interactiveParent.dataset.trendId;
                } else if (targetElement.classList.contains('trend-card')) {
                    delete targetElement.dataset.trendId;
                }
            });
        }

            document.getElementById('language-toggle')?.addEventListener('click', async (e) => {
                e.preventDefault(); // Ngăn chặn hành vi mặc định
                currentLanguage = currentLanguage === 'vi' ? 'en' : 'vi';
                localStorage.setItem('lang', currentLanguage);
                applyTranslations();
                updateLanguageToggleUI();
                
                // CẬP NHẬT: Không forceRefetch nữa nếu Builder Function đã cache tốt
                masterTrendsList = await fetchLiveTrends({ timeframe: '12m', region: 'global', category: 'All' }, false); 
                applyTrendOrdering();

                populateRegionsFilter(DOM.mainRegionFilter);
                populateRegionsFilter(DOM.tbRegionFilter);
                categories = [...new Set(masterTrendsList.map(trendItem => trendItem.category))].sort();
                populateCategoryFilters();
                populateMainTimeframeFilter();
                populateSourceFilter();
                populateHashtagFilters();

                if (currentView === 'trendingBoard') {
                    await createHotTrendsChart();
                } else {
                    displayTrends();
                }
            });

            // CẬP NHẬT: Tải preferences từ localStorage và khởi tạo user state
            const storedPreferences = localStorage.getItem('userPreferences');
            if (storedPreferences) {
                try {
                    user.preferences = JSON.parse(storedPreferences);
                    user.hasSetPreferences = true;
                } catch (e) {
                    console.error("Failed to parse stored preferences:", e);
                    localStorage.removeItem('userPreferences');
                    localStorage.removeItem('userHasSetPreferences');
                }
            }
            const storedHasSetPreferences = localStorage.getItem('userHasSetPreferences');
            if (storedHasSetPreferences === 'true') {
                user.hasSetPreferences = true;
            }
        
            initializeApp();
        });
    </script>
</body>
</html>
